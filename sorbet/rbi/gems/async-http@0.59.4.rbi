# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async-http` gem.
# Please instead update this file by running `bin/tapioca gem async-http`.

# source://async-http//lib/async/http/body/writable.rb#26
module Async; end

# source://async-http//lib/async/http/body/writable.rb#27
module Async::HTTP; end

# source://async-http//lib/async/http/body/writable.rb#28
module Async::HTTP::Body
  include ::Protocol::HTTP::Body
end

# A body which is designed for hijacked server responses - a response which uses a block to read and write the request and response bodies respectively.
#
# source://async-http//lib/async/http/body/hijack.rb#32
class Async::HTTP::Body::Hijack < ::Protocol::HTTP::Body::Readable
  # @return [Hijack] a new instance of Hijack
  #
  # source://async-http//lib/async/http/body/hijack.rb#41
  def initialize(block, input = T.unsafe(nil)); end

  # source://async-http//lib/async/http/body/hijack.rb#55
  def call(stream); end

  # Has the producer called #finish and has the reader consumed the nil token?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/hijack.rb#62
  def empty?; end

  # Returns the value of attribute input.
  #
  # source://async-http//lib/async/http/body/hijack.rb#59
  def input; end

  # source://async-http//lib/async/http/body/hijack.rb#86
  def inspect; end

  # Read the next available chunk.
  #
  # source://async-http//lib/async/http/body/hijack.rb#71
  def read; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/hijack.rb#66
  def ready?; end

  # We prefer streaming directly as it's the lowest overhead.
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/hijack.rb#51
  def stream?; end

  # source://async-http//lib/async/http/body/hijack.rb#90
  def to_s; end

  class << self
    # source://async-http//lib/async/http/body/hijack.rb#33
    def response(request, status, headers, &block); end

    # source://async-http//lib/async/http/body/hijack.rb#37
    def wrap(request = T.unsafe(nil), &block); end
  end
end

# Invokes a callback once the body has finished reading.
#
# source://async-http//lib/async/http/statistics.rb#49
class Async::HTTP::Body::Statistics < ::Protocol::HTTP::Body::Wrapper
  # @return [Statistics] a new instance of Statistics
  #
  # source://async-http//lib/async/http/statistics.rb#50
  def initialize(start_time, body, callback); end

  # source://async-http//lib/async/http/statistics.rb#80
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute end_time.
  #
  # source://async-http//lib/async/http/statistics.rb#64
  def end_time; end

  # source://async-http//lib/async/http/statistics.rb#74
  def first_chunk_duration; end

  # Returns the value of attribute first_chunk_time.
  #
  # source://async-http//lib/async/http/statistics.rb#63
  def first_chunk_time; end

  # source://async-http//lib/async/http/statistics.rb#112
  def inspect; end

  # source://async-http//lib/async/http/statistics.rb#86
  def read; end

  # Returns the value of attribute sent.
  #
  # source://async-http//lib/async/http/statistics.rb#66
  def sent; end

  # Returns the value of attribute start_time.
  #
  # source://async-http//lib/async/http/statistics.rb#62
  def start_time; end

  # source://async-http//lib/async/http/statistics.rb#98
  def to_s; end

  # source://async-http//lib/async/http/statistics.rb#68
  def total_duration; end

  private

  # source://async-http//lib/async/http/statistics.rb#118
  def complete_statistics(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/statistics.rb#124
  def format_duration(seconds); end
end

# A dynamic body which you can write to and read from.
#
# source://async-http//lib/async/http/body/writable.rb#32
class Async::HTTP::Body::Writable < ::Protocol::HTTP::Body::Readable
  # @param length [Integer] The length of the response body if known.
  # @param queue [Async::Queue] Specify a different queue implementation, e.g. `Async::LimitedQueue.new(8)` to enable back-pressure streaming.
  # @return [Writable] a new instance of Writable
  #
  # source://async-http//lib/async/http/body/writable.rb#38
  def initialize(length = T.unsafe(nil), queue: T.unsafe(nil)); end

  # Write a single chunk to the body. Signal completion by calling `#finish`.
  #
  # source://async-http//lib/async/http/body/writable.rb#92
  def <<(chunk); end

  # Stop generating output; cause the next call to write to fail with the given error.
  #
  # source://async-http//lib/async/http/body/writable.rb#56
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#67
  def closed?; end

  # Has the producer called #finish and has the reader consumed the nil token?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#76
  def empty?; end

  # source://async-http//lib/async/http/body/writable.rb#105
  def inspect; end

  # source://async-http//lib/async/http/body/writable.rb#51
  def length; end

  # Read the next available chunk.
  #
  # source://async-http//lib/async/http/body/writable.rb#81
  def read; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/body/writable.rb#71
  def ready?; end

  # Write a single chunk to the body. Signal completion by calling `#finish`.
  #
  # source://async-http//lib/async/http/body/writable.rb#92
  def write(chunk); end

  private

  # source://async-http//lib/async/http/body/writable.rb#111
  def status; end
end

# source://async-http//lib/async/http/body/writable.rb#33
class Async::HTTP::Body::Writable::Closed < ::StandardError; end

# source://async-http//lib/async/http/client.rb#40
class Async::HTTP::Client < ::Protocol::HTTP::Methods
  # Provides a robust interface to a server.
  # * If there are no connections, it will create one.
  # * If there are already connections, it will reuse it.
  # * If a request fails, it will retry it up to N times if it was idempotent.
  # The client object will never become unusable. It internally manages persistent connections (or non-persistent connections if that's required).
  #
  # @param endpoint [Endpoint] the endpoint to connnect to.
  # @param protocol [Protocol::HTTP1 | Protocol::HTTP2 | Protocol::HTTPS] the protocol to use.
  # @param scheme [String] The default scheme to set to requests.
  # @param authority [String] The default authority to set to requests.
  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/client.rb#50
  def initialize(endpoint, protocol: T.unsafe(nil), scheme: T.unsafe(nil), authority: T.unsafe(nil), retries: T.unsafe(nil), connection_limit: T.unsafe(nil)); end

  # Returns the value of attribute authority.
  #
  # source://async-http//lib/async/http/client.rb#68
  def authority; end

  # source://async-http//lib/async/http/client.rb#95
  def call(request); end

  # source://async-http//lib/async/http/client.rb#86
  def close; end

  # Returns the value of attribute endpoint.
  #
  # source://async-http//lib/async/http/client.rb#61
  def endpoint; end

  # source://async-http//lib/async/http/client.rb#142
  def inspect; end

  # Returns the value of attribute pool.
  #
  # source://async-http//lib/async/http/client.rb#65
  def pool; end

  # Returns the value of attribute protocol.
  #
  # source://async-http//lib/async/http/client.rb#62
  def protocol; end

  # Returns the value of attribute retries.
  #
  # source://async-http//lib/async/http/client.rb#64
  def retries; end

  # Returns the value of attribute scheme.
  #
  # source://async-http//lib/async/http/client.rb#67
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/client.rb#70
  def secure?; end

  protected

  # source://async-http//lib/async/http/client.rb#195
  def make_pool(connection_limit); end

  # source://async-http//lib/async/http/client.rb#184
  def make_response(request, connection); end

  class << self
    # source://async-http//lib/async/http/client.rb#74
    def open(*arguments, **options, &block); end
  end
end

# source://async-http//lib/async/http/client.rb#38
Async::HTTP::DEFAULT_CONNECTION_LIMIT = T.let(T.unsafe(nil), T.untyped)

# source://async-http//lib/async/http/client.rb#37
Async::HTTP::DEFAULT_RETRIES = T.let(T.unsafe(nil), Integer)

# Represents a way to connect to a remote HTTP server.
#
# source://async-http//lib/async/http/endpoint.rb#33
class Async::HTTP::Endpoint < ::Async::IO::Endpoint
  # @option hostname
  # @option scheme
  # @option port
  # @option ssl_context
  # @option alpn_protocols
  # @param hostname [Hash] a customizable set of options
  # @param scheme [Hash] a customizable set of options
  # @param port [Hash] a customizable set of options
  # @param ssl_context [Hash] a customizable set of options
  # @param alpn_protocols [Hash] a customizable set of options
  # @raise [ArgumentError]
  # @return [Endpoint] a new instance of Endpoint
  #
  # source://async-http//lib/async/http/endpoint.rb#56
  def initialize(url, endpoint = T.unsafe(nil), **options); end

  # source://async-http//lib/async/http/endpoint.rb#90
  def address; end

  # source://async-http//lib/async/http/endpoint.rb#148
  def alpn_protocols; end

  # source://async-http//lib/async/http/endpoint.rb#129
  def authority(ignore_default_port = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#196
  def bind(*arguments, &block); end

  # source://async-http//lib/async/http/endpoint.rb#177
  def build_endpoint(endpoint = T.unsafe(nil)); end

  # source://async-http//lib/async/http/endpoint.rb#200
  def connect(&block); end

  # source://async-http//lib/async/http/endpoint.rb#108
  def default_port; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#112
  def default_port?; end

  # source://async-http//lib/async/http/endpoint.rb#204
  def each; end

  # source://async-http//lib/async/http/endpoint.rb#192
  def endpoint; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#216
  def eql?(other); end

  # source://async-http//lib/async/http/endpoint.rb#220
  def hash; end

  # The hostname is the server we are connecting to:
  #
  # source://async-http//lib/async/http/endpoint.rb#121
  def hostname; end

  # source://async-http//lib/async/http/endpoint.rb#84
  def inspect; end

  # source://async-http//lib/async/http/endpoint.rb#212
  def key; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#152
  def localhost?; end

  # Return the path and query components of the given URL.
  #
  # source://async-http//lib/async/http/endpoint.rb#138
  def path; end

  # source://async-http//lib/async/http/endpoint.rb#116
  def port; end

  # source://async-http//lib/async/http/endpoint.rb#98
  def protocol; end

  # source://async-http//lib/async/http/endpoint.rb#125
  def scheme; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/endpoint.rb#94
  def secure?; end

  # source://async-http//lib/async/http/endpoint.rb#165
  def ssl_context; end

  # We don't try to validate peer certificates when talking to localhost because they would always be self-signed.
  #
  # source://async-http//lib/async/http/endpoint.rb#157
  def ssl_verify_mode; end

  # source://async-http//lib/async/http/endpoint.rb#80
  def to_s; end

  # source://async-http//lib/async/http/endpoint.rb#70
  def to_url; end

  # Returns the value of attribute url.
  #
  # source://async-http//lib/async/http/endpoint.rb#88
  def url; end

  protected

  # source://async-http//lib/async/http/endpoint.rb#239
  def tcp_endpoint; end

  # source://async-http//lib/async/http/endpoint.rb#226
  def tcp_options; end

  class << self
    # Construct an endpoint with a specified scheme, hostname, optional path, and options.
    #
    # source://async-http//lib/async/http/endpoint.rb#41
    def for(scheme, hostname, path = T.unsafe(nil), **options); end

    # source://async-http//lib/async/http/endpoint.rb#34
    def parse(string, endpoint = T.unsafe(nil), **options); end
  end
end

# source://async-http//lib/async/http/internet.rb#32
class Async::HTTP::Internet
  # @return [Internet] a new instance of Internet
  #
  # source://async-http//lib/async/http/internet.rb#33
  def initialize(**options); end

  # Make a request to the internet with the given `method` and `url`.
  #
  # If you provide non-frozen headers, they may be mutated.
  #
  # source://async-http//lib/async/http/internet.rb#58
  def call(method, url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#42
  def client_for(endpoint); end

  # A cache of clients.
  #
  # source://async-http//lib/async/http/internet.rb#40
  def clients; end

  # source://async-http//lib/async/http/internet.rb#70
  def close; end

  # source://async-http//lib/async/http/internet.rb#79
  def connect(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def delete(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def get(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def head(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def link(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def options(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def patch(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def post(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def put(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def trace(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://async-http//lib/async/http/internet.rb#79
  def unlink(url, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  protected

  # source://async-http//lib/async/http/internet.rb#92
  def host_key(endpoint); end

  # source://async-http//lib/async/http/internet.rb#86
  def make_client(endpoint); end
end

# A protocol specifies a way in which to communicate with a remote peer.
#
# source://async-http//lib/async/http/protocol/request.rb#30
module Async::HTTP::Protocol; end

# source://async-http//lib/async/http/protocol/http1/request.rb#28
module Async::HTTP::Protocol::HTTP1
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#32
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http1.rb#40
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http1.rb#52
    def names; end

    # source://async-http//lib/async/http/protocol/http1.rb#46
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http1.rb#36
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#28
module Async::HTTP::Protocol::HTTP10
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#31
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http10.rb#39
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http10.rb#51
    def names; end

    # source://async-http//lib/async/http/protocol/http10.rb#45
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http10.rb#35
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http10.rb#29
Async::HTTP::Protocol::HTTP10::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http11.rb#28
module Async::HTTP::Protocol::HTTP11
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#31
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http11.rb#39
    def client(peer); end

    # source://async-http//lib/async/http/protocol/http11.rb#51
    def names; end

    # source://async-http//lib/async/http/protocol/http11.rb#45
    def server(peer); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http11.rb#35
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http11.rb#29
Async::HTTP::Protocol::HTTP11::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/client.rb#29
class Async::HTTP::Protocol::HTTP1::Client < ::Async::HTTP::Protocol::HTTP1::Connection
  # Used by the client to send requests to the remote server.
  #
  # source://async-http//lib/async/http/protocol/http1/client.rb#31
  def call(request, task: T.unsafe(nil)); end
end

# source://async-http//lib/async/http/protocol/http1/connection.rb#32
class Async::HTTP::Protocol::HTTP1::Connection < ::Protocol::HTTP1::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#33
  def initialize(stream, version); end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#64
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#62
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#42
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#46
  def http2?; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#58
  def peer; end

  # source://async-http//lib/async/http/protocol/http1/connection.rb#54
  def read_line; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#50
  def read_line?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#73
  def reusable?; end

  # Returns the value of attribute version.
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#40
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/connection.rb#69
  def viable?; end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#29
class Async::HTTP::Protocol::HTTP1::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#38
  def initialize(connection, authority, method, path, version, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/request.rb#47
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/request.rb#55
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/request.rb#51
  def hijack?; end

  class << self
    # source://async-http//lib/async/http/protocol/http1/request.rb#30
    def read(connection); end
  end
end

# source://async-http//lib/async/http/protocol/http1/request.rb#36
Async::HTTP::Protocol::HTTP1::Request::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/response.rb#29
class Async::HTTP::Protocol::HTTP1::Response < ::Async::HTTP::Protocol::Response
  # @param reason [String] HTTP response line reason, ignored.
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#39
  def initialize(connection, version, status, reason, headers, body); end

  # source://async-http//lib/async/http/protocol/http1/response.rb#47
  def connection; end

  # source://async-http//lib/async/http/protocol/http1/response.rb#55
  def hijack!; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http1/response.rb#51
  def hijack?; end

  class << self
    # source://async-http//lib/async/http/protocol/http1/response.rb#30
    def read(connection, request); end
  end
end

# source://async-http//lib/async/http/protocol/http1/response.rb#36
Async::HTTP::Protocol::HTTP1::Response::UPGRADE = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http1/server.rb#29
class Async::HTTP::Protocol::HTTP1::Server < ::Async::HTTP::Protocol::HTTP1::Connection
  # Server loop.
  #
  # source://async-http//lib/async/http/protocol/http1/server.rb#58
  def each(task: T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#30
  def fail_request(status); end

  # source://async-http//lib/async/http/protocol/http1/server.rb#35
  def next_request; end
end

# source://async-http//lib/async/http/protocol/http1.rb#30
Async::HTTP::Protocol::HTTP1::VERSION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/input.rb#28
module Async::HTTP::Protocol::HTTP2
  class << self
    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#32
    def bidirectional?; end

    # source://async-http//lib/async/http/protocol/http2.rb#54
    def client(peer, settings = T.unsafe(nil)); end

    # source://async-http//lib/async/http/protocol/http2.rb#76
    def names; end

    # source://async-http//lib/async/http/protocol/http2.rb#65
    def server(peer, settings = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://async-http//lib/async/http/protocol/http2.rb#36
    def trailer?; end
  end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#35
Async::HTTP::Protocol::HTTP2::AUTHORITY = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#40
Async::HTTP::Protocol::HTTP2::CLIENT_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#40
Async::HTTP::Protocol::HTTP2::CONNECTION = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#39
Async::HTTP::Protocol::HTTP2::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/client.rb#32
class Async::HTTP::Protocol::HTTP2::Client < ::Protocol::HTTP2::Client
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Client] a new instance of Client
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#35
  def initialize(stream); end

  # Used by the client to send requests to the remote server.
  #
  # @raise [::Protocol::HTTP2::Error]
  #
  # source://async-http//lib/async/http/protocol/http2/client.rb#48
  def call(request); end

  # source://async-http//lib/async/http/protocol/http2/client.rb#43
  def create_response; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#43
module Async::HTTP::Protocol::HTTP2::Connection
  # source://async-http//lib/async/http/protocol/http2/connection.rb#44
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#72
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#134
  def concurrency; end

  # Returns the value of attribute count.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#132
  def count; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#60
  def http1?; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#64
  def http2?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#128
  def peer; end

  # Returns the value of attribute promises.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#126
  def promises; end

  # @raise [RuntimeError]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#95
  def read_in_background(parent: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#143
  def reusable?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#68
  def start_connection; end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#58
  def stream; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#54
  def to_s; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#147
  def version; end

  # Can we use this connection to make requests?
  #
  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/connection.rb#139
  def viable?; end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#78
  def write_frame(frame); end

  # source://async-http//lib/async/http/protocol/http2/connection.rb#87
  def write_frames(&block); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#31
Async::HTTP::Protocol::HTTP2::HTTPS = T.let(T.unsafe(nil), String)

# A writable body which requests window updates when data is read from it.
#
# source://async-http//lib/async/http/protocol/http2/input.rb#30
class Async::HTTP::Protocol::HTTP2::Input < ::Async::HTTP::Body::Writable
  # @return [Input] a new instance of Input
  #
  # source://async-http//lib/async/http/protocol/http2/input.rb#31
  def initialize(stream, length); end

  # source://async-http//lib/async/http/protocol/http2/input.rb#38
  def read; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#33
Async::HTTP::Protocol::HTTP2::METHOD = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/output.rb#29
class Async::HTTP::Protocol::HTTP2::Output
  # @return [Output] a new instance of Output
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#30
  def initialize(stream, body, trailer = T.unsafe(nil)); end

  # This method should only be called from within the context of the output task.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#71
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#42
  def start(parent: T.unsafe(nil)); end

  # This method should only be called from within the context of the HTTP/2 stream.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#79
  def stop(error); end

  # Returns the value of attribute trailer.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#40
  def trailer; end

  # source://async-http//lib/async/http/protocol/http2/output.rb#52
  def window_updated(size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#56
  def write(chunk); end

  private

  # Reads chunks from the given body and writes them to the stream as fast as possible.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#97
  def passthrough(task); end

  # Send `maximum_size` bytes of data using the specified `stream`. If the buffer has no more chunks, `END_STREAM` will be sent on the final chunk.
  #
  # @param maximum_size [Integer] send up to this many bytes of data.
  # @param stream [Stream] the stream to use for sending data frames.
  # @return [String, nil] any data that could not be written.
  #
  # source://async-http//lib/async/http/protocol/http2/output.rb#117
  def send_data(chunk, maximum_size); end

  # source://async-http//lib/async/http/protocol/http2/output.rb#86
  def stream(task); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#34
Async::HTTP::Protocol::HTTP2::PATH = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/connection.rb#37
Async::HTTP::Protocol::HTTP2::PROTOCOL = T.let(T.unsafe(nil), String)

# Typically used on the server side to represent an incoming request, and write the response.
#
# source://async-http//lib/async/http/protocol/http2/request.rb#31
class Async::HTTP::Protocol::HTTP2::Request < ::Async::HTTP::Protocol::Request
  # @return [Request] a new instance of Request
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#104
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#112
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#120
  def hijack?; end

  # source://async-http//lib/async/http/protocol/http2/request.rb#128
  def send_response(response); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#110
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#116
  def valid?; end
end

# source://async-http//lib/async/http/protocol/http2/request.rb#124
Async::HTTP::Protocol::HTTP2::Request::NO_RESPONSE = T.let(T.unsafe(nil), Array)

# source://async-http//lib/async/http/protocol/http2/request.rb#32
class Async::HTTP::Protocol::HTTP2::Request::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#33
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#97
  def closed(error); end

  # source://async-http//lib/async/http/protocol/http2/request.rb#42
  def receive_initial_headers(headers, end_stream); end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/request.rb#40
  def request; end
end

# Typically used on the client side for writing a request and reading the incoming response.
#
# source://async-http//lib/async/http/protocol/http2/response.rb#31
class Async::HTTP::Protocol::HTTP2::Response < ::Async::HTTP::Protocol::Response
  # @return [Response] a new instance of Response
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#119
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#145
  def build_request(headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#129
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#137
  def head?; end

  # Returns the value of attribute request.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#127
  def request; end

  # Send a request and read it into this response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#178
  def send_request(request); end

  # Returns the value of attribute stream.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#126
  def stream; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#141
  def valid?; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#133
  def wait; end
end

# source://async-http//lib/async/http/protocol/http2/response.rb#32
class Async::HTTP::Protocol::HTTP2::Response::Stream < ::Async::HTTP::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#33
  def initialize(*_arg0); end

  # @raise [ProtocolError]
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#52
  def accept_push_promise_stream(promised_stream_id, headers); end

  # source://async-http//lib/async/http/protocol/http2/response.rb#106
  def closed(error); end

  # Notify anyone waiting on the response headers to be received (or failure).
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#89
  def notify!; end

  # This should be invoked from the background reader, and notifies the task waiting for the headers that we are done.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#57
  def receive_initial_headers(headers, end_stream); end

  # Returns the value of attribute response.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#42
  def response; end

  # Wait for the headers to be received or for stream reset.
  #
  # source://async-http//lib/async/http/protocol/http2/response.rb#97
  def wait; end

  # source://async-http//lib/async/http/protocol/http2/response.rb#44
  def wait_for_input; end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#32
Async::HTTP::Protocol::HTTP2::SCHEME = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#46
Async::HTTP::Protocol::HTTP2::SERVER_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://async-http//lib/async/http/protocol/http2/connection.rb#36
Async::HTTP::Protocol::HTTP2::STATUS = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2/server.rb#32
class Async::HTTP::Protocol::HTTP2::Server < ::Protocol::HTTP2::Server
  include ::Async::HTTP::Protocol::HTTP2::Connection

  # @return [Server] a new instance of Server
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#35
  def initialize(stream); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#48
  def accept_stream(stream_id); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#54
  def close(error = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/server.rb#64
  def each(task: T.unsafe(nil)); end

  # Returns the value of attribute requests.
  #
  # source://async-http//lib/async/http/protocol/http2/server.rb#46
  def requests; end
end

# source://async-http//lib/async/http/protocol/http2/stream.rb#32
class Async::HTTP::Protocol::HTTP2::Stream < ::Protocol::HTTP2::Stream
  # @return [Stream] a new instance of Stream
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#33
  def initialize(*_arg0); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#50
  def add_header(key, value); end

  # When the stream transitions to the closed state, this method is called. There are roughly two ways this can happen:
  # - A frame is received which causes this stream to enter the closed state. This method will be invoked from the background reader task.
  # - A frame is sent which causes this stream to enter the closed state. This method will be invoked from that task.
  # While the input stream is relatively straight forward, the output stream can trigger the second case above
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#166
  def closed(error); end

  # Called when the output terminates normally.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#139
  def finish_output(error = T.unsafe(nil)); end

  # Returns the value of attribute headers.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#46
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#46
  def headers=(_arg0); end

  # Returns the value of attribute input.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#48
  def input; end

  # Prepare the input stream which will be used for incoming data frames.
  #
  # @return [Input] the input body.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#95
  def prepare_input(length); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#110
  def process_data(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#68
  def process_headers(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#62
  def receive_trailing_headers(headers, end_stream); end

  # Set the body and begin sending it.
  #
  # source://async-http//lib/async/http/protocol/http2/stream.rb#132
  def send_body(body, trailer = T.unsafe(nil)); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#103
  def update_local_window(frame); end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#89
  def wait_for_input; end

  # source://async-http//lib/async/http/protocol/http2/stream.rb#156
  def window_updated(size); end
end

# source://async-http//lib/async/http/protocol/http2/connection.rb#41
Async::HTTP::Protocol::HTTP2::TRAILER = T.let(T.unsafe(nil), String)

# source://async-http//lib/async/http/protocol/http2.rb#30
Async::HTTP::Protocol::HTTP2::VERSION = T.let(T.unsafe(nil), String)

# A server that supports both HTTP1.0 and HTTP1.1 semantics by detecting the version of the request.
#
# source://async-http//lib/async/http/protocol/https.rb#50
module Async::HTTP::Protocol::HTTPS
  class << self
    # source://async-http//lib/async/http/protocol/https.rb#71
    def client(peer); end

    # Supported Application Layer Protocol Negotiation names:
    #
    # source://async-http//lib/async/http/protocol/https.rb#80
    def names; end

    # source://async-http//lib/async/http/protocol/https.rb#58
    def protocol_for(peer); end

    # source://async-http//lib/async/http/protocol/https.rb#75
    def server(peer); end
  end
end

# source://async-http//lib/async/http/protocol/https.rb#51
Async::HTTP::Protocol::HTTPS::HANDLERS = T.let(T.unsafe(nil), Hash)

# This is generated by server protocols.
#
# source://async-http//lib/async/http/protocol/request.rb#36
class Async::HTTP::Protocol::Request < ::Protocol::HTTP::Request
  # source://async-http//lib/async/http/protocol/request.rb#37
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/request.rb#41
  def hijack?; end

  # source://async-http//lib/async/http/protocol/request.rb#45
  def peer; end

  # source://async-http//lib/async/http/protocol/request.rb#51
  def remote_address; end

  # source://async-http//lib/async/http/protocol/request.rb#55
  def remote_address=(value); end
end

# Failed to send the request. The request body has NOT been consumed (i.e. #read) and you should retry the request.
#
# source://async-http//lib/async/http/protocol/request.rb#32
class Async::HTTP::Protocol::RequestFailed < ::StandardError; end

# This is generated by client protocols.
#
# source://async-http//lib/async/http/protocol/response.rb#31
class Async::HTTP::Protocol::Response < ::Protocol::HTTP::Response
  # source://async-http//lib/async/http/protocol/response.rb#32
  def connection; end

  # @return [Boolean]
  #
  # source://async-http//lib/async/http/protocol/response.rb#36
  def hijack?; end

  # source://async-http//lib/async/http/protocol/response.rb#40
  def peer; end

  # source://async-http//lib/async/http/protocol/response.rb#46
  def remote_address; end

  # source://async-http//lib/async/http/protocol/response.rb#50
  def remote_address=(value); end
end

# source://async-http//lib/async/http/server.rb#34
class Async::HTTP::Server < ::Protocol::HTTP::Middleware
  # @return [Server] a new instance of Server
  #
  # source://async-http//lib/async/http/server.rb#39
  def initialize(app, endpoint, protocol: T.unsafe(nil), scheme: T.unsafe(nil)); end

  # source://async-http//lib/async/http/server.rb#51
  def accept(peer, address, task: T.unsafe(nil)); end

  # Returns the value of attribute endpoint.
  #
  # source://async-http//lib/async/http/server.rb#47
  def endpoint; end

  # Returns the value of attribute protocol.
  #
  # source://async-http//lib/async/http/server.rb#48
  def protocol; end

  # source://async-http//lib/async/http/server.rb#73
  def run; end

  # Returns the value of attribute scheme.
  #
  # source://async-http//lib/async/http/server.rb#49
  def scheme; end

  class << self
    # source://async-http//lib/async/http/server.rb#35
    def for(*arguments, **options, &block); end
  end
end

# source://async-http//lib/async/http/statistics.rb#29
class Async::HTTP::Statistics
  # @return [Statistics] a new instance of Statistics
  #
  # source://async-http//lib/async/http/statistics.rb#34
  def initialize(start_time); end

  # source://async-http//lib/async/http/statistics.rb#38
  def wrap(response, &block); end

  class << self
    # source://async-http//lib/async/http/statistics.rb#30
    def start; end
  end
end

# source://async/2.3.0/lib/async/version.rb#7
Async::VERSION = T.let(T.unsafe(nil), String)
