# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `guard` gem.
# Please instead update this file by running `bin/tapioca gem guard`.

# Guard is the main module for all Guard related modules and classes.
# Also Guard plugins should use this namespace.
#
# source://guard//lib/guard/config.rb#3
module Guard
  extend ::Guard::Deprecated::Guard::ClassMethods
  extend ::Guard::Internals::Helpers

  class << self
    # Asynchronously trigger changes
    #
    # Currently supported args:
    #
    #   @example Old style hash:
    #     async_queue_add(modified: ['foo'], added: ['bar'], removed: [])
    #
    #   @example New style signals with args:
    #     async_queue_add([:guard_pause, :unpaused ])
    #
    # source://guard//lib/guard.rb#87
    def async_queue_add(changes); end

    # source://guard//lib/guard.rb#73
    def init(cmdline_options); end

    # Returns the value of attribute interactor.
    #
    # source://guard//lib/guard.rb#24
    def interactor; end

    # Returns the value of attribute listener.
    #
    # source://guard//lib/guard.rb#23
    def listener; end

    # Returns the value of attribute queue.
    #
    # source://guard//lib/guard.rb#22
    def queue; end

    # Initializes the Guard singleton:
    #
    # * Initialize the internal Guard state;
    # * Create the interactor
    # * Select and initialize the file change listener.
    #
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @option options
    # @param options [Hash] a customizable set of options
    # @return [Guard] the Guard singleton
    #
    # source://guard//lib/guard.rb#44
    def setup(cmdline_options = T.unsafe(nil)); end

    # Returns the value of attribute state.
    #
    # source://guard//lib/guard.rb#21
    def state; end

    private

    # source://guard//lib/guard.rb#132
    def _evaluate(options); end

    # TODO: remove at some point
    # TODO: not tested because collides with ongoing refactoring
    #
    # source://guard//lib/guard.rb#152
    def _guardfile_deprecated_check(modified); end

    # source://guard//lib/guard.rb#113
    def _listener_callback; end

    # TODO: obsoleted? (move to Dsl?)
    #
    # @return [Boolean]
    #
    # source://guard//lib/guard.rb#128
    def _pluginless_guardfile?; end

    # source://guard//lib/guard.rb#109
    def _relative_pathnames(paths); end

    # Check if any of the changes are actually watched for
    # TODO: why iterate twice? reuse this info when running tasks
    #
    # @return [Boolean]
    #
    # source://guard//lib/guard.rb#99
    def _relevant_changes?(changes); end
  end
end

# source://guard//lib/guard/config.rb#9
class Guard::Config < ::Nenv::Environment
  # @return [Config] a new instance of Config
  #
  # source://guard//lib/guard/config.rb#10
  def initialize; end

  # @return [Boolean]
  #
  # source://guard//lib/guard/config.rb#14
  def silence_deprecations?; end
end

# @deprecated Every method in this module is deprecated
#
# source://guard//lib/guard/deprecated/watcher.rb#5
module Guard::Deprecated; end

# source://guard//lib/guard/deprecated/dsl.rb#6
module Guard::Deprecated::Dsl
  class << self
    # source://guard//lib/guard/deprecated/dsl.rb#7
    def add_deprecated(dsl_klass); end
  end
end

# source://guard//lib/guard/deprecated/dsl.rb#16
module Guard::Deprecated::Dsl::ClassMethods
  # source://guard//lib/guard/deprecated/dsl.rb#35
  def evaluate_guardfile(options = T.unsafe(nil)); end
end

# `Guard::Guardfile::Evaluator.new(options).evaluate_guardfile`
# instead.
#
# to upgrade for Guard 2.0
#
# @deprecated Use
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How
#
# source://guard//lib/guard/deprecated/dsl.rb#24
Guard::Deprecated::Dsl::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/dsl.rb#11
Guard::Deprecated::Dsl::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/evaluator.rb#8
module Guard::Deprecated::Evaluator
  # source://guard//lib/guard/deprecated/evaluator.rb#26
  def evaluate_guardfile; end

  # source://guard//lib/guard/deprecated/evaluator.rb#31
  def reevaluate_guardfile; end

  class << self
    # source://guard//lib/guard/deprecated/evaluator.rb#9
    def add_deprecated(klass); end
  end
end

# source://guard//lib/guard/deprecated/evaluator.rb#13
Guard::Deprecated::Evaluator::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/evaluator.rb#18
Guard::Deprecated::Evaluator::REEVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#14
module Guard::Deprecated::Guard
  class << self
    # source://guard//lib/guard/deprecated/guard.rb#15
    def add_deprecated(klass); end
  end
end

# source://guard//lib/guard/deprecated/guard.rb#19
module Guard::Deprecated::Guard::ClassMethods
  # source://guard//lib/guard/deprecated/guard.rb#251
  def add_group(name, options = T.unsafe(nil)); end

  # source://guard//lib/guard/deprecated/guard.rb#57
  def add_guard(*args); end

  # source://guard//lib/guard/deprecated/guard.rb#261
  def add_plugin(name, options = T.unsafe(nil)); end

  # source://guard//lib/guard/deprecated/guard.rb#179
  def evaluate_guardfile; end

  # source://guard//lib/guard/deprecated/guard.rb#152
  def evaluator; end

  # source://guard//lib/guard/deprecated/guard.rb#79
  def get_guard_class(name, fail_gracefully = T.unsafe(nil)); end

  # source://guard//lib/guard/deprecated/guard.rb#271
  def group(filter); end

  # source://guard//lib/guard/deprecated/guard.rb#291
  def groups(filter); end

  # source://guard//lib/guard/deprecated/guard.rb#116
  def guard_gem_names; end

  # source://guard//lib/guard/deprecated/guard.rb#38
  def guards(filter = T.unsafe(nil)); end

  # source://guard//lib/guard/deprecated/guard.rb#143
  def listener=(_); end

  # source://guard//lib/guard/deprecated/guard.rb#97
  def locate_guard(name); end

  # source://guard//lib/guard/deprecated/guard.rb#135
  def lock; end

  # source://guard//lib/guard/deprecated/guard.rb#195
  def options; end

  # source://guard//lib/guard/deprecated/guard.rb#281
  def plugin(filter); end

  # source://guard//lib/guard/deprecated/guard.rb#301
  def plugins(filter); end

  # source://guard//lib/guard/deprecated/guard.rb#162
  def reset_evaluator(_options); end

  # source://guard//lib/guard/deprecated/guard.rb#170
  def runner; end

  # source://guard//lib/guard/deprecated/guard.rb#126
  def running; end

  # source://guard//lib/guard/deprecated/guard.rb#311
  def scope; end

  # source://guard//lib/guard/deprecated/guard.rb#321
  def scope=(scope); end
end

# source://guard//lib/guard/deprecated/guard.rb#246
Guard::Deprecated::Guard::ClassMethods::ADD_GROUP = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard.add_plugin(name, options = {})` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
#
# source://guard//lib/guard/deprecated/guard.rb#48
Guard::Deprecated::Guard::ClassMethods::ADD_GUARD = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#256
Guard::Deprecated::Guard::ClassMethods::ADD_PLUGIN = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#175
Guard::Deprecated::Guard::ClassMethods::EVALUATE_GUARDFILE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#148
Guard::Deprecated::Guard::ClassMethods::EVALUATOR = T.let(T.unsafe(nil), String)

# @deprecated Use
#   `Guard::PluginUtil.new(name).plugin_class(fail_gracefully:
#   fail_gracefully)` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
#
# source://guard//lib/guard/deprecated/guard.rb#69
Guard::Deprecated::Guard::ClassMethods::GET_GUARD_CLASS = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#266
Guard::Deprecated::Guard::ClassMethods::GROUP = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#286
Guard::Deprecated::Guard::ClassMethods::GROUPS = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard.plugins(filter)` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
#
# source://guard//lib/guard/deprecated/guard.rb#30
Guard::Deprecated::Guard::ClassMethods::GUARDS = T.let(T.unsafe(nil), String)

# Deprecator message for the `Guard.guard_gem_names` method
#
# @deprecated Use `Guard::PluginUtil.plugin_names` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
#
# source://guard//lib/guard/deprecated/guard.rb#108
Guard::Deprecated::Guard::ClassMethods::GUARD_GEM_NAMES = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#139
Guard::Deprecated::Guard::ClassMethods::LISTENER_ASSIGN = T.let(T.unsafe(nil), String)

# @deprecated Use `Guard::PluginUtil.new(name).plugin_location` instead.
# @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
#   upgrade for Guard 2.0
#
# source://guard//lib/guard/deprecated/guard.rb#89
Guard::Deprecated::Guard::ClassMethods::LOCATE_GUARD = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#131
Guard::Deprecated::Guard::ClassMethods::LOCK = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#20
Guard::Deprecated::Guard::ClassMethods::MORE_INFO_ON_UPGRADING_TO_GUARD_2 = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#188
Guard::Deprecated::Guard::ClassMethods::OPTIONS = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#276
Guard::Deprecated::Guard::ClassMethods::PLUGIN = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#296
Guard::Deprecated::Guard::ClassMethods::PLUGINS = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#158
Guard::Deprecated::Guard::ClassMethods::RESET_EVALUATOR = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#166
Guard::Deprecated::Guard::ClassMethods::RUNNER = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#121
Guard::Deprecated::Guard::ClassMethods::RUNNING = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#306
Guard::Deprecated::Guard::ClassMethods::SCOPE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/guard.rb#316
Guard::Deprecated::Guard::ClassMethods::SCOPE_ASSIGN = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/deprecated/watcher.rb#6
module Guard::Deprecated::Watcher
  class << self
    # source://guard//lib/guard/deprecated/watcher.rb#7
    def add_deprecated(klass); end
  end
end

# source://guard//lib/guard/deprecated/watcher.rb#11
module Guard::Deprecated::Watcher::ClassMethods
  # @return [Boolean]
  #
  # source://guard//lib/guard/deprecated/watcher.rb#16
  def match_guardfile?(files); end
end

# source://guard//lib/guard/deprecated/watcher.rb#12
Guard::Deprecated::Watcher::ClassMethods::MATCH_GUARDFILE = T.let(T.unsafe(nil), String)

# The Dsl class provides the methods that are used in each `Guardfile` to
# describe the behaviour of Guard.
#
# The main keywords of the DSL are {#guard} and {#watch}. These are necessary
# to define the used Guard plugins and the file changes they are watching.
#
# You can optionally group the Guard plugins with the {#group} keyword and
# ignore and filter certain paths with the {#ignore} and {#filter} keywords.
#
# You can set your preferred system notification library with {#notification}
# and pass some optional configuration options for the library. If you don't
# configure a library, Guard will automatically pick one with default options
# (if you don't want notifications, specify `:off` as library). Please see
# {Notifier} for more information about the supported libraries.
#
# A more advanced DSL use is the {#callback} keyword that allows you to
# execute arbitrary code before or after any of the {Plugin#start},
# {Plugin#stop}, {Plugin#reload}, {Plugin#run_all},
# {Plugin#run_on_changes}, {Plugin#run_on_additions},
# {Plugin#run_on_modifications} and {Plugin#run_on_removals}
# Guard plugins method.
# You can even insert more hooks inside these methods. Please [checkout the
# Wiki page](https://github.com/guard/guard/wiki/Hooks-and-callbacks) for
# more details.
#
# The DSL will also evaluate normal Ruby code.
#
# There are two possible locations for the `Guardfile`:
#
# * The `Guardfile` or `guardfile.rb` in the current directory where Guard
#   has been started
# * The `.Guardfile` in your home directory.
#
# In addition, if a user configuration `.guard.rb` in your home directory is
# found, it will be appended to the current project `Guardfile`.
#
# @see https://github.com/guard/guard/wiki/Guardfile-examples
#
# source://guard//lib/guard/dsl.rb#49
class Guard::Dsl
  extend ::Guard::Deprecated::Dsl::ClassMethods

  # Defines a callback to execute arbitrary code before or after any of
  # the `start`, `stop`, `reload`, `run_all`, `run_on_changes`,
  # `run_on_additions`, `run_on_modifications` and `run_on_removals` plugin
  # method.
  #
  # @example Add callback before the `reload` action.
  #   callback(:reload_begin) { puts "Let's reload!" }
  # @example Add callback before the `start` and `stop` actions.
  #
  #   my_lambda = lambda do |plugin, event, *args|
  #   puts "Let's #{event} #{plugin} with #{args}!"
  #   end
  #
  #   callback(my_lambda, [:start_begin, :start_end])
  # @param args [Array] the callback arguments
  # @yield a callback block
  #
  # source://guard//lib/guard/dsl.rb#246
  def callback(*args, &block); end

  # Sets Guard to clear the screen before every task is run
  #
  # @example switching clearing the screen on
  #   clearing(:on)
  # @param on [Symbol] ':on' to turn on, ':off' (default) to turn off
  #
  # source://guard//lib/guard/dsl.rb#408
  def clearing(on); end

  # Sets the directories to pass to Listen
  #
  # @example watch only given directories
  #   directories %w(lib specs)
  # @param directories [Array] directories for Listen to watch
  #
  # source://guard//lib/guard/dsl.rb#394
  def directories(directories); end

  # :nodoc
  #
  # source://guard//lib/guard/dsl.rb#377
  def evaluate(contents, filename, lineno); end

  # Ignores certain paths globally.
  # TODO: deprecate
  #
  # @example Ignore some paths
  #   ignore %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  #
  # source://guard//lib/guard/dsl.rb#267
  def filter(*regexps); end

  # Replaces ignored paths globally
  # TODO: deprecate
  #
  # @example Ignore only these paths
  #   ignore! %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  #
  # source://guard//lib/guard/dsl.rb#282
  def filter!(*regexps); end

  # Declares a group of Guard plugins to be run with `guard start --group
  #   group_name`.
  #
  # @example Declare two groups of Guard plugins
  #   group :backend do
  #   guard :spork
  #   guard :rspec
  #   end
  #
  #   group :frontend do
  #   guard :passenger
  #   guard :livereload
  #   end
  # @param name [Symbol, String, Array<Symbol, String>] the group name called
  #   from the CLI
  # @param options [Hash] the options accepted by the group
  # @see Group
  # @see Guard.add_group
  # @see #guard
  # @yield a block where you can declare several Guard plugins
  #
  # source://guard//lib/guard/dsl.rb#124
  def group(*args); end

  # Declares a Guard plugin to be used when running `guard start`.
  #
  # The name parameter is usually the name of the gem without
  # the 'guard-' prefix.
  #
  # The available options are different for each Guard implementation.
  #
  # @example Declare a Guard without `watch` patterns
  #   guard :rspec
  # @example Declare a Guard with a `watch` pattern
  #   guard :rspec do
  #   watch %r{.*_spec.rb}
  #   end
  # @param name [String] the Guard plugin name
  # @param options [Hash] the options accepted by the Guard plugin
  # @see Plugin
  # @see Guard.add_plugin
  # @see #watch
  # @see #group
  # @yield a block where you can declare several watch patterns and actions
  #
  # source://guard//lib/guard/dsl.rb#176
  def guard(name, options = T.unsafe(nil)); end

  # Ignores certain paths globally.
  #
  # @example Ignore some paths
  #   ignore %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  #
  # source://guard//lib/guard/dsl.rb#267
  def ignore(*regexps); end

  # Replaces ignored paths globally
  #
  # @example Ignore only these paths
  #   ignore! %r{^ignored/path/}, /man/
  # @param regexps [Regexp] a pattern (or list of patterns) for ignoring paths
  #
  # source://guard//lib/guard/dsl.rb#282
  def ignore!(*regexps); end

  # Sets the interactor options or disable the interactor.
  #
  # @example Pass options to the interactor
  #   interactor option1: 'value1', option2: 'value2'
  # @example Turn off interactions
  #   interactor :off
  # @param options [Symbol, Hash] either `:off` or a Hash with interactor
  #   options
  #
  # source://guard//lib/guard/dsl.rb#91
  def interactor(options); end

  # Configures the Guard logger.
  #
  # * Log level must be either `:debug`, `:info`, `:warn` or `:error`.
  # * Template supports the following placeholders: `:time`, `:severity`,
  #   `:progname`, `:pid`, `:unit_of_work_id` and `:message`.
  # * Time format directives are the same as `Time#strftime` or
  #   `:milliseconds`.
  # * The `:only` and `:except` options must be a `RegExp`.
  #
  # @example Set the log level
  #   logger level: :warn
  # @example Set a custom log template
  #   logger template: '[Guard - :severity - :progname - :time] :message'
  # @example Set a custom time format
  #   logger time_format: '%h'
  # @example Limit logging to a Guard plugin
  #   logger only: :jasmine
  # @example Log all but not the messages from a specific Guard plugin
  #   logger except: :jasmine
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the log options
  #
  # source://guard//lib/guard/dsl.rb#325
  def logger(options); end

  # Set notification options for the system notifications.
  # You can set multiple notifications, which allows you to show local
  # system notifications and remote notifications with separate libraries.
  # You can also pass `:off` as library to turn off notifications.
  #
  # @example Define multiple notifications
  #   notification :ruby_gntp
  #   notification :ruby_gntp, host: '192.168.1.5'
  # @param notifier [Symbol, String] the name of the notifier to use
  # @param opts [Hash] the notification library options
  # @see Guard::Notifier for available notifier and its options.
  #
  # source://guard//lib/guard/dsl.rb#76
  def notification(notifier, opts = T.unsafe(nil)); end

  # Sets the default scope on startup
  #
  # @example Scope Guard to a single group
  #   scope group: :frontend
  # @example Scope Guard to multiple groups
  #   scope groups: [:specs, :docs]
  # @example Scope Guard to a single plugin
  #   scope plugin: :test
  # @example Scope Guard to multiple plugins
  #   scope plugins: [:jasmine, :rspec]
  # @param scope [Hash] the scope for the groups and plugins
  #
  # source://guard//lib/guard/dsl.rb#372
  def scope(scope = T.unsafe(nil)); end

  # Defines a pattern to be watched in order to run actions on file
  # modification.
  #
  # modification
  #
  # @example Declare global watchers outside of a Guard
  #   watch(%r{^(.+)$}) { |m| puts "#{m[1]} changed." }
  # @example Declare watchers for a Guard
  #   guard :rspec do
  #   watch('spec/spec_helper.rb')
  #   watch(%r{^.+_spec.rb})
  #   watch(%r{^app/controllers/(.+).rb}) do |m|
  #   'spec/acceptance/#{m[1]}s_spec.rb'
  #   end
  #   end
  # @param pattern [String, Regexp] the pattern that Guard must watch for
  # @see #guard
  # @see Guard::Watcher
  # @yield a block to be run when the pattern is matched
  # @yieldparam m [MatchData] matches of the pattern
  # @yieldreturn a directory, a filename, an array of
  #   directories / filenames, or nothing (can be an arbitrary command)
  #
  # source://guard//lib/guard/dsl.rb#218
  def watch(pattern, &action); end

  private

  # source://guard//lib/guard/dsl.rb#414
  def _cleanup_backtrace(backtrace); end
end

# Wrap exceptions during parsing Guardfile
#
# source://guard//lib/guard/dsl.rb#53
class Guard::Dsl::Error < ::RuntimeError; end

# source://guard//lib/guard/dsl.rb#56
Guard::Dsl::WARN_INVALID_LOG_LEVEL = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/dsl.rb#59
Guard::Dsl::WARN_INVALID_LOG_OPTIONS = T.let(T.unsafe(nil), String)

# TODO: this should probably be a base class for Dsl instead (in Guard 3.x)
#
# source://guard//lib/guard/dsl_reader.rb#5
class Guard::DslReader < ::Guard::Dsl
  # @return [DslReader] a new instance of DslReader
  #
  # source://guard//lib/guard/dsl_reader.rb#8
  def initialize; end

  # source://guard//lib/guard/dsl_reader.rb#30
  def callback(*_args, &_block); end

  # source://guard//lib/guard/dsl_reader.rb#48
  def clearing(_on); end

  # source://guard//lib/guard/dsl_reader.rb#45
  def directories(_directories); end

  # source://guard//lib/guard/dsl_reader.rb#24
  def group(*_args); end

  # source://guard//lib/guard/dsl_reader.rb#13
  def guard(name, _options = T.unsafe(nil)); end

  # source://guard//lib/guard/dsl_reader.rb#33
  def ignore(*_regexps); end

  # source://guard//lib/guard/dsl_reader.rb#36
  def ignore!(*_regexps); end

  # source://guard//lib/guard/dsl_reader.rb#21
  def interactor(_options); end

  # source://guard//lib/guard/dsl_reader.rb#39
  def logger(_options); end

  # Stub everything else
  #
  # source://guard//lib/guard/dsl_reader.rb#18
  def notification(_notifier, _opts = T.unsafe(nil)); end

  # Returns the value of attribute plugin_names.
  #
  # source://guard//lib/guard/dsl_reader.rb#6
  def plugin_names; end

  # source://guard//lib/guard/dsl_reader.rb#42
  def scope(_scope = T.unsafe(nil)); end

  # source://guard//lib/guard/dsl_reader.rb#27
  def watch(_pattern, &_action); end
end

# A group of Guard plugins. There are two reasons why you want to group your
# Guard plugins:
#
# * You can start only certain groups from the command line by passing the
#   `--group` option to `guard start`.
# * Abort task execution chain on failure within a group with the
#   `:halt_on_fail` option.
#
# @example Group that aborts on failure
#
#   group :frontend, halt_on_fail: true do
#   guard 'coffeescript', input: 'spec/coffeescripts',
#   output: 'spec/javascripts'
#   guard 'jasmine-headless-webkit' do
#   watch(%r{^spec/javascripts/(.*)\..*}) do |m|
#   newest_js_file("spec/javascripts/#{m[1]}_spec")
#   end
#   end
#   end
# @see Guard::CLI
#
# source://guard//lib/guard/group.rb#24
class Guard::Group
  # Initializes a Group.
  #
  # @option options
  # @param name [String] the name of the group
  # @param options [Hash] the group options
  # @return [Group] a new instance of Group
  #
  # source://guard//lib/guard/group.rb#35
  def initialize(name, options = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://guard//lib/guard/group.rb#25
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://guard//lib/guard/group.rb#25
  def name=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://guard//lib/guard/group.rb#25
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://guard//lib/guard/group.rb#25
  def options=(_arg0); end

  # Returns the group title.
  #
  # @example Title for a group named 'backend'
  #   > Guard::Group.new('backend').title
  #   => "Backend"
  # @return [String]
  #
  # source://guard//lib/guard/group.rb#48
  def title; end

  # String representation of the group.
  #
  # @example String representation of a group named 'backend'
  #   > Guard::Group.new('backend').to_s
  #   => "#<Guard::Group @name=backend @options={}>"
  # @return [String] the string representation
  #
  # source://guard//lib/guard/group.rb#60
  def to_s; end
end

# source://guard//lib/guard/guardfile/evaluator.rb#11
module Guard::Guardfile; end

# This class is responsible for evaluating the Guardfile. It delegates to
# Guard::Dsl for the actual objects generation from the Guardfile content.
#
# TODO: rename this to a Locator or Loader or something
#
# @see Guard::Dsl
#
# source://guard//lib/guard/guardfile/evaluator.rb#18
class Guard::Guardfile::Evaluator
  include ::Guard::Deprecated::Evaluator

  # Initializes a new Guard::Guardfile::Evaluator object.
  #
  # content of a valid Guardfile
  #
  # @option opts
  # @option opts
  # @param opts [Hash] a customizable set of options
  # @return [Evaluator] a new instance of Evaluator
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#57
  def initialize(opts = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#121
  def custom?; end

  # Evaluates the DSL methods in the `Guardfile`.
  #
  # path
  #
  #   options = { guardfile: '/Users/guardfile/MyAwesomeGuardfile' }
  #   Guard::Guardfile::Evaluator.new(options).evaluate
  #
  # @example Programmatically evaluate a Guardfile
  #   Guard::Guardfile::Evaluator.new.evaluate
  # @example Programmatically evaluate a Guardfile with a custom Guardfile
  # @example Programmatically evaluate a Guardfile with an inline Guardfile
  #
  #   options = { contents: 'guard :rspec' }
  #   Guard::Guardfile::Evaluator.new(options).evaluate
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#89
  def evaluate; end

  # Gets the content of the `Guardfile` concatenated with the global
  # user configuration file.
  #
  # @example Programmatically get the content of the current Guardfile
  #   Guard::Guardfile::Evaluator.new.guardfile_contents
  #   => "guard :rspec"
  # @return [String] the Guardfile content
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#134
  def guardfile_contents; end

  # Tests if the current `Guardfile` contains a specific Guard plugin.
  #
  # plugin
  #
  #   File.read('Guardfile')
  #   => "guard :rspec"
  #
  #   Guard::Guardfile::Evaluator.new.guardfile_include?('rspec)
  #   => true
  #
  # TODO: rename this method to it matches RSpec examples better
  #
  # @example Programmatically test if a Guardfile contains a specific Guard
  # @param plugin_name [String] the name of the Guard
  # @return [Boolean] whether the Guard plugin has been declared
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#113
  def guardfile_include?(plugin_name); end

  # Returns the value of attribute guardfile_path.
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#30
  def guardfile_path; end

  # source://guard//lib/guard/guardfile/evaluator.rb#47
  def guardfile_source; end

  # @return [Boolean]
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#139
  def inline?; end

  # Returns the value of attribute options.
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#30
  def options; end

  # Returns the value of attribute path.
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#119
  def path; end

  private

  # source://guard//lib/guard/guardfile/evaluator.rb#156
  def _fetch_guardfile_contents; end

  # source://guard//lib/guard/guardfile/evaluator.rb#223
  def _from_deprecated(opts); end

  # source://guard//lib/guard/guardfile/evaluator.rb#212
  def _guardfile_contents; end

  # @return [Boolean]
  #
  # source://guard//lib/guard/guardfile/evaluator.rb#219
  def _guardfile_contents_usable?; end

  # source://guard//lib/guard/guardfile/evaluator.rb#145
  def _guardfile_contents_without_user_config; end

  # source://guard//lib/guard/guardfile/evaluator.rb#149
  def _instance_eval_guardfile(contents); end

  # source://guard//lib/guard/guardfile/evaluator.rb#200
  def _read(path); end

  # source://guard//lib/guard/guardfile/evaluator.rb#186
  def _use_default!; end

  # source://guard//lib/guard/guardfile/evaluator.rb#165
  def _use_inline; end

  # source://guard//lib/guard/guardfile/evaluator.rb#178
  def _use_provided; end
end

# source://guard//lib/guard/guardfile/evaluator.rb#21
Guard::Guardfile::Evaluator::DEFAULT_GUARDFILES = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/guardfile/evaluator.rb#27
Guard::Guardfile::Evaluator::ERROR_NO_GUARDFILE = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/guardfile/evaluator.rb#32
Guard::Guardfile::Evaluator::ERROR_NO_PLUGINS = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/guardfile/evaluator.rb#35
class Guard::Guardfile::Evaluator::Error < ::RuntimeError; end

# source://guard//lib/guard/guardfile/evaluator.rb#41
class Guard::Guardfile::Evaluator::NoCustomGuardfile < ::Guard::Guardfile::Evaluator::Error; end

# source://guard//lib/guard/guardfile/evaluator.rb#38
class Guard::Guardfile::Evaluator::NoGuardfileError < ::Guard::Guardfile::Evaluator::Error; end

# source://guard//lib/guard/guardfile/evaluator.rb#44
class Guard::Guardfile::Evaluator::NoPluginsError < ::Guard::Guardfile::Evaluator::Error; end

# source://guard//lib/guard/interactor.rb#4
class Guard::Interactor
  extend ::Forwardable

  # Initializes the interactor. This configures
  # Pry and creates some custom commands and aliases
  # for Guard.
  #
  # @return [Interactor] a new instance of Interactor
  #
  # source://guard//lib/guard/interactor.rb#9
  def initialize(no_interaction = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def background(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def foreground(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def handle_interrupt(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/interactor.rb#20
  def interactive?; end

  private

  # Returns the value of attribute idle_job.
  #
  # source://guard//lib/guard/interactor.rb#51
  def idle_job; end

  class << self
    # TODO: allow custom user idle jobs, e.g. [:pry, :sleep, :exit, ...]
    #
    # @return [Boolean]
    #
    # source://guard//lib/guard/interactor.rb#39
    def enabled; end

    # TODO: handle switching interactors during runtime?
    #
    # source://guard//lib/guard/interactor.rb#46
    def enabled=(_arg0); end

    # TODO: allow custom user idle jobs, e.g. [:pry, :sleep, :exit, ...]
    #
    # @return [Boolean]
    #
    # source://guard//lib/guard/interactor.rb#39
    def enabled?; end

    # source://guard//lib/guard/interactor.rb#31
    def options; end

    # Pass options to interactor's job when it's created
    #
    # source://guard//lib/guard/interactor.rb#36
    def options=(_arg0); end
  end
end

# @private api
#
# source://guard//lib/guard/internals/groups.rb#5
module Guard::Internals; end

# source://guard//lib/guard/internals/debugging.rb#12
class Guard::Internals::Debugging
  class << self
    # Sets up debugging:
    #
    # * aborts on thread exceptions
    # * Set the logging level to `:debug`
    # * traces execution of Kernel.system and backtick calls
    #
    # source://guard//lib/guard/internals/debugging.rb#26
    def start; end

    # source://guard//lib/guard/internals/debugging.rb#38
    def stop; end

    private

    # source://guard//lib/guard/internals/debugging.rb#46
    def _notify(*args); end

    # reset singleton - called by tests
    #
    # source://guard//lib/guard/internals/debugging.rb#51
    def _reset; end

    # source://guard//lib/guard/internals/debugging.rb#58
    def _trace(mod, meth, &block); end

    # source://guard//lib/guard/internals/debugging.rb#62
    def _untrace(mod, meth); end
  end
end

# source://guard//lib/guard/internals/groups.rb#6
class Guard::Internals::Groups
  # @return [Groups] a new instance of Groups
  #
  # source://guard//lib/guard/internals/groups.rb#9
  def initialize; end

  # source://guard//lib/guard/internals/groups.rb#19
  def add(name, options = T.unsafe(nil)); end

  # source://guard//lib/guard/internals/groups.rb#13
  def all(filter = T.unsafe(nil)); end

  private

  # source://guard//lib/guard/internals/groups.rb#28
  def matcher_for(filter); end
end

# source://guard//lib/guard/internals/groups.rb#7
Guard::Internals::Groups::DEFAULT_GROUPS = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/internals/helpers.rb#4
module Guard::Internals::Helpers
  # source://guard//lib/guard/internals/helpers.rb#5
  def _relative_pathname(path); end
end

# source://guard//lib/guard/internals/plugins.rb#8
class Guard::Internals::Plugins
  # @return [Plugins] a new instance of Plugins
  #
  # source://guard//lib/guard/internals/plugins.rb#9
  def initialize; end

  # TODO: should it allow duplicates? (probably yes because of different
  # configs or groups)
  #
  # source://guard//lib/guard/internals/plugins.rb#25
  def add(name, options); end

  # source://guard//lib/guard/internals/plugins.rb#13
  def all(filter = T.unsafe(nil)); end

  # source://guard//lib/guard/internals/plugins.rb#19
  def remove(plugin); end

  private

  # source://guard//lib/guard/internals/plugins.rb#31
  def matcher_for(filter); end
end

# source://guard//lib/guard/internals/queue.rb#3
class Guard::Internals::Queue
  # @return [Queue] a new instance of Queue
  #
  # source://guard//lib/guard/internals/queue.rb#4
  def initialize(commander); end

  # source://guard//lib/guard/internals/queue.rb#31
  def <<(changes); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/internals/queue.rb#27
  def pending?; end

  # Process the change queue, running tasks within the main Guard thread
  #
  # source://guard//lib/guard/internals/queue.rb#10
  def process; end

  private

  # source://guard//lib/guard/internals/queue.rb#37
  def _run_actions(actions); end
end

# source://guard//lib/guard/internals/scope.rb#6
class Guard::Internals::Scope
  # @return [Scope] a new instance of Scope
  #
  # source://guard//lib/guard/internals/scope.rb#7
  def initialize; end

  # source://guard//lib/guard/internals/scope.rb#51
  def from_interactor(scope); end

  # TODO: refactor
  #
  # source://guard//lib/guard/internals/scope.rb#20
  def grouped_plugins(scope = T.unsafe(nil)); end

  # source://guard//lib/guard/internals/scope.rb#56
  def titles(scope = T.unsafe(nil)); end

  # source://guard//lib/guard/internals/scope.rb#12
  def to_hash; end

  private

  # source://guard//lib/guard/internals/scope.rb#108
  def _find_non_empty_scope(type, local_scope); end

  # source://guard//lib/guard/internals/scope.rb#112
  def _groups; end

  # TODO: let the Plugins and Groups classes handle this?
  # TODO: why even instantiate?? just to check if it exists?
  #
  # source://guard//lib/guard/internals/scope.rb#77
  def _hashify_scope(type); end

  # source://guard//lib/guard/internals/scope.rb#102
  def _instantiate(meth, obj); end

  # source://guard//lib/guard/internals/scope.rb#116
  def _plugins; end

  # TODO: move to session
  #
  # source://guard//lib/guard/internals/scope.rb#68
  def _scope_names(new_scope, name); end
end

# TODO: split into a commandline class and session (plugins, groups)
# TODO: swap session and metadata
#
# source://guard//lib/guard/internals/session.rb#11
class Guard::Internals::Session
  # @return [Session] a new instance of Session
  #
  # source://guard//lib/guard/internals/session.rb#51
  def initialize(new_options); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/internals/session.rb#102
  def clear?; end

  # source://guard//lib/guard/internals/session.rb#98
  def clearing(on); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/internals/session.rb#102
  def clearing?; end

  # source://guard//lib/guard/internals/session.rb#43
  def cmdline_groups; end

  # source://guard//lib/guard/internals/session.rb#47
  def cmdline_plugins; end

  # TODO: call this from within action, not within interactor command
  #
  # source://guard//lib/guard/internals/session.rb#162
  def convert_scope(entries); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/internals/session.rb#108
  def debug?; end

  # source://guard//lib/guard/internals/session.rb#136
  def evaluator_options; end

  # Returns the value of attribute groups.
  #
  # source://guard//lib/guard/internals/session.rb#13
  def groups; end

  # TODO: create a EvaluatorResult class?
  #
  # source://guard//lib/guard/internals/session.rb#89
  def guardfile_group_scope; end

  # Returns the value of attribute guardfile_ignore.
  #
  # source://guard//lib/guard/internals/session.rb#93
  def guardfile_ignore; end

  # source://guard//lib/guard/internals/session.rb#94
  def guardfile_ignore=(ignores); end

  # Returns the value of attribute guardfile_ignore_bang.
  #
  # source://guard//lib/guard/internals/session.rb#91
  def guardfile_ignore_bang; end

  # Sets the attribute guardfile_ignore_bang
  #
  # @param value the value to set the attribute guardfile_ignore_bang to.
  #
  # source://guard//lib/guard/internals/session.rb#91
  def guardfile_ignore_bang=(_arg0); end

  # source://guard//lib/guard/internals/session.rb#155
  def guardfile_notification=(config); end

  # Returns the value of attribute guardfile_plugin_scope.
  #
  # source://guard//lib/guard/internals/session.rb#90
  def guardfile_plugin_scope; end

  # source://guard//lib/guard/internals/session.rb#74
  def guardfile_scope(scope); end

  # Returns the value of attribute interactor_name.
  #
  # source://guard//lib/guard/internals/session.rb#159
  def interactor_name; end

  # source://guard//lib/guard/internals/session.rb#123
  def listener_args; end

  # source://guard//lib/guard/internals/session.rb#145
  def notify_options; end

  # Returns the value of attribute plugins.
  #
  # source://guard//lib/guard/internals/session.rb#12
  def plugins; end

  # source://guard//lib/guard/internals/session.rb#112
  def watchdirs; end

  # set by Dsl with :directories() command
  #
  # source://guard//lib/guard/internals/session.rb#118
  def watchdirs=(dirs); end
end

# source://guard//lib/guard/internals/session.rb#15
Guard::Internals::Session::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://guard//lib/guard/internals/state.rb#10
class Guard::Internals::State
  # Minimal setup for non-interactive commands (list, init, show, etc.)
  #
  # @return [State] a new instance of State
  #
  # source://guard//lib/guard/internals/state.rb#12
  def initialize(cmdline_opts); end

  # Returns the value of attribute scope.
  #
  # source://guard//lib/guard/internals/state.rb#21
  def scope; end

  # Returns the value of attribute session.
  #
  # source://guard//lib/guard/internals/state.rb#22
  def session; end
end

# source://guard//lib/guard/internals/tracing.rb#3
module Guard::Internals::Tracing
  class << self
    # source://guard//lib/guard/internals/tracing.rb#4
    def trace(mod, meth); end

    # source://guard//lib/guard/internals/tracing.rb#19
    def untrace(mod, meth); end
  end
end

# source://guard//lib/guard/internals/traps.rb#3
module Guard::Internals::Traps
  class << self
    # source://guard//lib/guard/internals/traps.rb#4
    def handle(signal, &block); end
  end
end

# source://guard//lib/guard/notifier.rb#5
class Guard::Notifier
  class << self
    # source://guard//lib/guard/notifier.rb#6
    def connect(options = T.unsafe(nil)); end

    # Used by dsl describer
    #
    # source://guard//lib/guard/notifier.rb#65
    def detected; end

    # source://guard//lib/guard/notifier.rb#18
    def disconnect; end

    # source://guard//lib/guard/notifier.rb#27
    def notify(message, options = T.unsafe(nil)); end

    # Used by dsl describer
    #
    # source://guard//lib/guard/notifier.rb#60
    def supported; end

    # source://guard//lib/guard/notifier.rb#44
    def toggle; end

    # source://guard//lib/guard/notifier.rb#40
    def turn_on; end
  end
end

# source://guard//lib/guard/notifier.rb#23
Guard::Notifier::DEPRECATED_IMPLICIT_CONNECT = T.let(T.unsafe(nil), String)

# A class that holds options. Can be instantiated with default options.
#
# source://guard//lib/guard/options.rb#12
class Guard::Options < ::Thor::CoreExt::HashWithIndifferentAccess
  # Initializes an Guard::Options object. `default_opts` is merged into
  # `opts`.
  #
  # @param opts [Hash] the options
  # @param default_opts [Hash] the default options
  # @return [Options] a new instance of Options
  #
  # source://guard//lib/guard/options.rb#13
  def initialize(opts = T.unsafe(nil), default_opts = T.unsafe(nil)); end

  # workaround for: https://github.com/erikhuda/thor/issues/504
  #
  # source://guard//lib/guard/options.rb#18
  def fetch(name); end
end

# Base class from which every Guard plugin implementation must inherit.
#
# Guard will trigger the {#start}, {#stop}, {#reload}, {#run_all} and
# {#run_on_changes} ({#run_on_additions}, {#run_on_modifications} and
# {#run_on_removals}) task methods depending on user interaction and file
# modification.
#
# {#run_on_changes} could be implemented to handle all the changes task case
# (additions, modifications, removals) in once, or each task can be
# implemented separately with a specific behavior.
#
# In each of these Guard task methods you have to implement some work when
# you want to support this kind of task. The return value of each Guard task
# method is not evaluated by Guard, but it'll be passed to the "_end" hook
# for further evaluation. You can throw `:task_has_failed` to indicate that
# your Guard plugin method was not successful, and successive Guard plugin
# tasks will be aborted when the group has set the `:halt_on_fail` option.
#
# Each Guard plugin should provide a template Guardfile located within the Gem
# at `lib/guard/guard-name/templates/Guardfile`.
#
# Watchers for a Guard plugin should return a file path or an array of files
# paths to Guard, but if your Guard plugin wants to allow any return value
# from a watcher, you can set the `any_return` option to true.
#
# If one of those methods raises an exception other than `:task_has_failed`,
# the `Guard::GuardName` instance will be removed from the active Guard
# plugins.
#
# @example Throw :task_has_failed
#
#   def run_all
#   if !runner.run(['all'])
#   throw :task_has_failed
#   end
#   end
# @see Guard::Group
#
# source://guard//lib/guard/plugin.rb#44
class Guard::Plugin
  # Initializes a Guard plugin.
  # Don't do any work here, especially as Guard plugins get initialized even
  # if they are not in an active group!
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash] the Guard plugin options
  # @return [Plugin] a new instance of Plugin
  #
  # source://guard//lib/guard/plugin.rb#285
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute callbacks.
  #
  # source://guard//lib/guard/plugin.rb#129
  def callbacks; end

  # Sets the attribute callbacks
  #
  # @param value the value to set the attribute callbacks to.
  #
  # source://guard//lib/guard/plugin.rb#129
  def callbacks=(_arg0); end

  # Returns the value of attribute group.
  #
  # source://guard//lib/guard/plugin.rb#129
  def group; end

  # Sets the attribute group
  #
  # @param value the value to set the attribute group to.
  #
  # source://guard//lib/guard/plugin.rb#129
  def group=(_arg0); end

  # When event is a Symbol, {#hook} will generate a hook name
  # by concatenating the method name from where {#hook} is called
  # with the given Symbol.
  #
  # Here, when {Guard::Plugin#run_all} is called, {#hook} will notify
  # callbacks registered for the "run_all_foo" event.
  #
  # When event is a String, {#hook} will directly turn the String
  # into a Symbol.
  #
  # When {Guard::Plugin::run_all} is called, {#hook} will notify
  # callbacks registered for the "foo_bar" event.
  #
  # @example Add a hook with a Symbol
  #
  #   def run_all
  #   hook :foo
  #   end
  # @example Add a hook with a String
  #
  #   def run_all
  #   hook "foo_bar"
  #   end
  # @param event [Symbol, String] the name of the Guard event
  # @param args [Array] the parameters are passed as is to the callbacks
  #   registered for the given event.
  #
  # source://guard//lib/guard/plugin.rb#116
  def hook(event, *args); end

  # Returns the plugin's name (without "guard-").
  #
  # @example Name for Guard::RSpec
  #   Guard::RSpec.new.name
  #   #=> "rspec"
  # @return [String]
  #
  # source://guard//lib/guard/plugin.rb#240
  def name; end

  # Returns the value of attribute options.
  #
  # source://guard//lib/guard/plugin.rb#129
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://guard//lib/guard/plugin.rb#129
  def options=(_arg0); end

  # Returns the plugin's class name without the Guard:: namespace.
  #
  # @example Title for Guard::RSpec
  #   Guard::RSpec.new.title
  #   #=> "RSpec"
  # @return [String]
  #
  # source://guard//lib/guard/plugin.rb#252
  def title; end

  # String representation of the plugin.
  #
  # @example String representation of an instance of the Guard::RSpec plugin
  #
  #   Guard::RSpec.new.title
  #   #=> "#<Guard::RSpec @name=rspec @group=#<Guard::Group @name=default
  #   @options={}> @watchers=[] @callbacks=[] @options={all_after_pass:
  #   true}>"
  # @return [String] the string representation
  #
  # source://guard//lib/guard/plugin.rb#267
  def to_s; end

  # Returns the value of attribute watchers.
  #
  # source://guard//lib/guard/plugin.rb#129
  def watchers; end

  # Sets the attribute watchers
  #
  # @param value the value to set the attribute watchers to.
  #
  # source://guard//lib/guard/plugin.rb#129
  def watchers=(_arg0); end

  private

  # Add all the Guard::Plugin's callbacks to the global @callbacks array
  # that's used by Guard to know which callbacks to notify.
  #
  # source://guard//lib/guard/plugin.rb#297
  def _register_callbacks; end

  class << self
    # Add a callback.
    #
    # @param listener [Block] the listener to notify
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param events [Array<Symbol>] the events to register
    #
    # source://guard//lib/guard/plugin.rb#62
    def add_callback(listener, guard_plugin, events); end

    # Get all callbacks registered for all Guard plugins present in the
    # Guardfile.
    #
    # source://guard//lib/guard/plugin.rb#52
    def callbacks; end

    # Returns the non-namespaced class name of the plugin
    #
    # @example Non-namespaced class name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_classname
    #   #=> "RSpec"
    # @return [String]
    #
    # source://guard//lib/guard/plugin.rb#140
    def non_namespaced_classname; end

    # Returns the non-namespaced name of the plugin
    #
    # @example Non-namespaced name for Guard::RSpec
    #   Guard::RSpec.non_namespaced_name
    #   #=> "rspec"
    # @return [String]
    #
    # source://guard//lib/guard/plugin.rb#153
    def non_namespaced_name; end

    # Notify a callback.
    #
    # @param guard_plugin [Guard::Plugin] the Guard plugin to add the callback
    # @param event [Symbol] the event to trigger
    # @param args [Array] the arguments for the listener
    #
    # source://guard//lib/guard/plugin.rb#74
    def notify(guard_plugin, event, *args); end

    # Reset all callbacks.
    #
    # TODO: remove (not used anywhere)
    #
    # source://guard//lib/guard/plugin.rb#83
    def reset_callbacks!; end

    # Specify the source for the Guardfile template.
    # Each Guard plugin can redefine this method to add its own logic.
    #
    # @param plugin_location [String] the plugin location
    #
    # source://guard//lib/guard/plugin.rb#162
    def template(plugin_location); end
  end
end

# source://guard//lib/guard/plugin.rb#45
Guard::Plugin::TEMPLATE_FORMAT = T.let(T.unsafe(nil), String)

# This class contains useful methods to:
#
# * Fetch all the Guard plugins names;
# * Initialize a plugin, get its location;
# * Return its class name;
# * Add its template to the Guardfile.
#
# source://guard//lib/guard/plugin_util.rb#11
class Guard::PluginUtil
  # Initializes a new `Guard::PluginUtil` object.
  #
  # @param name [String] the name of the Guard plugin
  # @return [PluginUtil] a new instance of PluginUtil
  #
  # source://guard//lib/guard/plugin_util.rb#36
  def initialize(name); end

  # Adds a plugin's template to the Guardfile.
  #
  # source://guard//lib/guard/plugin_util.rb#126
  def add_to_guardfile; end

  # Initializes a new `Guard::Plugin` with the given `options` hash. This
  # methods handles plugins that inherit from the deprecated `Guard::Guard`
  # class as well as plugins that inherit from `Guard::Plugin`.
  #
  # upgrade for Guard 2.0
  #
  # @return [Guard::Plugin] the initialized plugin
  # @return [Guard::Guard] the initialized plugin. This return type is
  #   deprecated and the plugin's maintainer should update it to be
  #   compatible with Guard 2.0. For more information on how to upgrade for
  #   Guard 2.0, please head over to:
  #   https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0
  # @see Guard::Plugin
  # @see https://github.com/guard/guard/wiki/Upgrading-to-Guard-2.0 How to
  #
  # source://guard//lib/guard/plugin_util.rb#55
  def initialize_plugin(options); end

  # Returns the value of attribute name.
  #
  # source://guard//lib/guard/plugin_util.rb#18
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://guard//lib/guard/plugin_util.rb#18
  def name=(_arg0); end

  # Tries to load the Guard plugin main class. This transforms the supplied
  # plugin name into a class name:
  #
  # * `guardname` will become `Guard::Guardname`
  # * `dashed-guard-name` will become `Guard::DashedGuardName`
  # * `underscore_guard_name` will become `Guard::UnderscoreGuardName`
  #
  # When no class is found with the strict case sensitive rules, another
  # try is made to locate the class without matching case:
  #
  # * `rspec` will find a class `Guard::RSpec`
  #
  # not be printed
  #
  # @option options
  # @param options [Hash] a customizable set of options
  # @return [Class, nil] the loaded class
  #
  # source://guard//lib/guard/plugin_util.rb#96
  def plugin_class(options = T.unsafe(nil)); end

  # Locates a path to a Guard plugin gem.
  #
  # @return [String] the full path to the plugin gem
  #
  # source://guard//lib/guard/plugin_util.rb#73
  def plugin_location; end

  private

  # Guesses the most probable name for the current plugin based on its name.
  #
  # @example Returns the most probable name for a plugin
  #   > Guard::PluginUtil.new('rspec').send(:_constant_name)
  #   => "Rspec"
  #
  # source://guard//lib/guard/plugin_util.rb#172
  def _constant_name; end

  # source://guard//lib/guard/plugin_util.rb#177
  def _full_gem_path(name); end

  # Returns the constant for the current plugin.
  #
  # @example Returns the constant for a plugin
  #   > Guard::PluginUtil.new('rspec').send(:_plugin_constant)
  #   => Guard::RSpec
  #
  # source://guard//lib/guard/plugin_util.rb#160
  def _plugin_constant; end

  class << self
    # @return [Boolean]
    #
    # source://guard//lib/guard/plugin_util.rb#182
    def _gem_valid?(gem); end

    # Returns a list of Guard plugin Gem names installed locally.
    #
    # @return [Array<String>] a list of Guard plugin gem names
    #
    # source://guard//lib/guard/plugin_util.rb#24
    def plugin_names; end
  end
end

# source://guard//lib/guard/plugin_util.rb#12
Guard::PluginUtil::ERROR_NO_GUARD_OR_CLASS = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/plugin_util.rb#15
Guard::PluginUtil::INFO_ADDED_GUARD_TO_GUARDFILE = T.let(T.unsafe(nil), String)

# The runner is responsible for running all methods defined on each plugin.
#
# source://guard//lib/guard/runner.rb#9
class Guard::Runner
  # Run a Guard plugin task, but remove the Guard plugin when his work leads
  # to a system failure.
  #
  # When the Group has `:halt_on_fail` disabled, we've to catch
  # `:task_has_failed` here in order to avoid an uncaught throw error.
  #
  # @param plugin [Guard::Plugin] guard the Guard to execute
  # @param task [Symbol] the task to run
  # @param args [Array] the arguments for the task
  # @raise [:task_has_failed] when task has failed
  #
  # source://guard//lib/guard/runner.rb#78
  def _supervise(plugin, task, *args); end

  # Runs a Guard-task on all registered plugins.
  #
  # on
  #
  # @param task [Symbol] the task to run
  # @param scope_hash [Hash] either the Guard plugin or the group to run the task
  #
  # source://guard//lib/guard/runner.rb#17
  def run(task, scope_hash = T.unsafe(nil)); end

  # Runs the appropriate tasks on all registered plugins
  # based on the passed changes.
  #
  # @param modified [Array<String>] the modified paths.
  # @param added [Array<String>] the added paths.
  # @param removed [Array<String>] the removed paths.
  #
  # source://guard//lib/guard/runner.rb#44
  def run_on_changes(modified, added, removed); end

  private

  # source://guard//lib/guard/runner.rb#116
  def _run_group_plugins(plugins); end

  class << self
    # Returns the symbol that has to be caught when running a supervised task.
    #
    # @note If a Guard group is being run and it has the `:halt_on_fail`
    #   option set, this method returns :no_catch as it will be caught at the
    #   group level.
    # @param guard [Guard::Plugin] the Guard plugin to execute
    # @return [Symbol] the symbol to catch
    #
    # source://guard//lib/guard/runner.rb#110
    def stopping_symbol_for(guard); end
  end
end

# source://guard//lib/guard/runner.rb#34
Guard::Runner::ADDITION_TASKS = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/runner.rb#30
Guard::Runner::MODIFICATION_TASKS = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/runner.rb#28
Guard::Runner::PLUGIN_FAILED = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/runner.rb#35
Guard::Runner::REMOVAL_TASKS = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/terminal.rb#4
class Guard::Terminal
  class << self
    # source://guard//lib/guard/terminal.rb#6
    def clear; end
  end
end

# The UI class helps to format messages for the user. Everything that is
# logged through this class is considered either as an error message or a
# diagnostic message and is written to standard error ($stderr).
#
# If your Guard plugin does some output that is piped into another process
# for further processing, please just write it to STDOUT with `puts`.
#
# source://guard//lib/guard/ui/colors.rb#2
module Guard::UI
  include ::Guard::UI::Colors

  class << self
    # Show a scoped action message.
    #
    # @param action [String] the action to show
    # @param scope [Hash] hash with a guard or a group scope
    #
    # source://guard//lib/guard/ui.rb#161
    def action_with_scopes(action, scope); end

    # Clear the output if clearable.
    #
    # source://guard//lib/guard/ui.rb#131
    def clear(opts = T.unsafe(nil)); end

    # Allow the screen to be cleared again.
    #
    # source://guard//lib/guard/ui.rb#152
    def clearable; end

    # Show a debug message that is prefixed with DEBUG and a timestamp.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    #
    # source://guard//lib/guard/ui.rb#119
    def debug(message, options = T.unsafe(nil)); end

    # Show a red deprecation message that is prefixed with DEPRECATION.
    # It has a log level of `warn`.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    #
    # source://guard//lib/guard/ui.rb#105
    def deprecation(message, options = T.unsafe(nil)); end

    # Show a red error message that is prefixed with ERROR.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    #
    # source://guard//lib/guard/ui.rb#94
    def error(message, options = T.unsafe(nil)); end

    # Show an info message.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    #
    # source://guard//lib/guard/ui.rb#74
    def info(message, options = T.unsafe(nil)); end

    # Assigns a log level
    #
    # source://guard//lib/guard/ui.rb#63
    def level=(new_level); end

    # Get the Guard::UI logger instance
    #
    # source://guard//lib/guard/ui.rb#26
    def logger; end

    # Get the logger options
    #
    # @return [Hash] the logger options
    #
    # source://guard//lib/guard/ui.rb#46
    def options; end

    # Set the logger options
    #
    # TODO: deprecate?
    #
    # @option options
    # @option options
    # @option options
    # @param options [Hash] the logger options
    #
    # source://guard//lib/guard/ui.rb#58
    def options=(options); end

    # TODO: arguments: UI uses Guard::options anyway
    #
    # @private api
    #
    # source://guard//lib/guard/ui.rb#145
    def reset_and_clear; end

    # Reset a line.
    #
    # source://guard//lib/guard/ui.rb#125
    def reset_line; end

    # Since logger is global, for Aruba in-process to properly
    # separate output between calls, we need to reset
    #
    # We don't use logger=() since it's expected to be a Lumberjack instance
    #
    # source://guard//lib/guard/ui.rb#38
    def reset_logger; end

    # Show a yellow warning message that is prefixed with WARNING.
    #
    # @option options
    # @option options
    # @param message [String] the message to show
    # @param options [Hash] a customizable set of options
    #
    # source://guard//lib/guard/ui.rb#84
    def warning(message, options = T.unsafe(nil)); end

    private

    # Tries to extract the calling Guard plugin name
    # from the call stack.
    #
    # @param depth [Integer] the stack depth
    # @return [String] the Guard plugin name
    #
    # source://guard//lib/guard/ui.rb#203
    def _calling_plugin_name; end

    # Filters log messages depending on either the
    # `:only`` or `:except` option.
    #
    # @param plugin [String] the calling plugin name
    # @yield When the message should be logged
    # @yieldparam param [String] the calling plugin name
    #
    # source://guard//lib/guard/ui.rb#175
    def _filter(plugin); end

    # @private
    #
    # source://guard//lib/guard/ui.rb#188
    def _filtered_logger_message(message, method, color_name, options = T.unsafe(nil)); end

    # Colorizes a text message. See the constant in the UI class for possible
    # color_options parameters. You can pass optionally :bright, a foreground
    # color and a background color.
    #
    # @example
    #
    #   color('Hello World', :red, :bright)
    # @param text [String] the text to colorize
    # @param color_options [Array] the color options
    #
    # source://guard//lib/guard/ui.rb#247
    def color(text, *color_options); end

    # Checks if color output can be enabled.
    #
    # @return [Boolean] whether color is enabled or not
    #
    # source://guard//lib/guard/ui.rb#217
    def color_enabled?; end
  end
end

# source://guard//lib/guard/ui/colors.rb#3
module Guard::UI::Colors; end

# Black background color
#
# source://guard//lib/guard/ui/colors.rb#32
Guard::UI::Colors::ANSI_ESCAPE_BGBLACK = T.let(T.unsafe(nil), String)

# Blue background color
#
# source://guard//lib/guard/ui/colors.rb#44
Guard::UI::Colors::ANSI_ESCAPE_BGBLUE = T.let(T.unsafe(nil), String)

# Cyan background color
#
# source://guard//lib/guard/ui/colors.rb#50
Guard::UI::Colors::ANSI_ESCAPE_BGCYAN = T.let(T.unsafe(nil), String)

# Green background color
#
# source://guard//lib/guard/ui/colors.rb#38
Guard::UI::Colors::ANSI_ESCAPE_BGGREEN = T.let(T.unsafe(nil), String)

# Magenta background color
#
# source://guard//lib/guard/ui/colors.rb#47
Guard::UI::Colors::ANSI_ESCAPE_BGMAGENTA = T.let(T.unsafe(nil), String)

# Red background color
#
# source://guard//lib/guard/ui/colors.rb#35
Guard::UI::Colors::ANSI_ESCAPE_BGRED = T.let(T.unsafe(nil), String)

# White background color
#
# source://guard//lib/guard/ui/colors.rb#53
Guard::UI::Colors::ANSI_ESCAPE_BGWHITE = T.let(T.unsafe(nil), String)

# Yellow background color
#
# source://guard//lib/guard/ui/colors.rb#41
Guard::UI::Colors::ANSI_ESCAPE_BGYELLOW = T.let(T.unsafe(nil), String)

# Black foreground color
#
# source://guard//lib/guard/ui/colors.rb#8
Guard::UI::Colors::ANSI_ESCAPE_BLACK = T.let(T.unsafe(nil), String)

# Blue foreground color
#
# source://guard//lib/guard/ui/colors.rb#20
Guard::UI::Colors::ANSI_ESCAPE_BLUE = T.let(T.unsafe(nil), String)

# Brighten the color
#
# source://guard//lib/guard/ui/colors.rb#5
Guard::UI::Colors::ANSI_ESCAPE_BRIGHT = T.let(T.unsafe(nil), String)

# Cyan foreground color
#
# source://guard//lib/guard/ui/colors.rb#26
Guard::UI::Colors::ANSI_ESCAPE_CYAN = T.let(T.unsafe(nil), String)

# Green foreground color
#
# source://guard//lib/guard/ui/colors.rb#14
Guard::UI::Colors::ANSI_ESCAPE_GREEN = T.let(T.unsafe(nil), String)

# Magenta foreground color
#
# source://guard//lib/guard/ui/colors.rb#23
Guard::UI::Colors::ANSI_ESCAPE_MAGENTA = T.let(T.unsafe(nil), String)

# Red foreground color
#
# source://guard//lib/guard/ui/colors.rb#11
Guard::UI::Colors::ANSI_ESCAPE_RED = T.let(T.unsafe(nil), String)

# White foreground color
#
# source://guard//lib/guard/ui/colors.rb#29
Guard::UI::Colors::ANSI_ESCAPE_WHITE = T.let(T.unsafe(nil), String)

# Yellow foreground color
#
# source://guard//lib/guard/ui/colors.rb#17
Guard::UI::Colors::ANSI_ESCAPE_YELLOW = T.let(T.unsafe(nil), String)

# source://guard//lib/guard/ui/config.rb#6
class Guard::UI::Config < ::Guard::Options
  # @return [Config] a new instance of Config
  #
  # source://guard//lib/guard/ui/config.rb#20
  def initialize(options = T.unsafe(nil)); end

  # source://guard//lib/guard/ui/config.rb#48
  def [](name); end

  # source://guard//lib/guard/ui/config.rb#35
  def device; end

  # source://guard//lib/guard/ui/config.rb#44
  def except; end

  # Returns the value of attribute logger_config.
  #
  # source://guard//lib/guard/ui/config.rb#18
  def logger_config; end

  # source://guard//lib/guard/ui/config.rb#40
  def only; end

  # source://guard//lib/guard/ui/config.rb#59
  def with_progname(name); end
end

# source://guard//lib/guard/ui/config.rb#7
Guard::UI::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://guard//lib/guard/ui/config.rb#16
Guard::UI::Config::DEPRECATED_OPTS = T.let(T.unsafe(nil), Array)

# source://guard//lib/guard/ui/logger.rb#5
class Guard::UI::Logger; end

# source://guard//lib/guard/ui/logger.rb#6
class Guard::UI::Logger::Config < ::Guard::Options
  # @return [Config] a new instance of Config
  #
  # source://guard//lib/guard/ui/logger.rb#20
  def initialize(options = T.unsafe(nil)); end

  # source://guard//lib/guard/ui/logger.rb#24
  def level=(value); end
end

# source://guard//lib/guard/ui/logger.rb#7
Guard::UI::Logger::Config::DEFAULTS = T.let(T.unsafe(nil), Hash)

# The watcher defines a RegExp that will be matched against file system
# modifications.
# When a watcher matches a change, an optional action block is executed to
# enable processing the file system change result.
#
# source://guard//lib/guard/watcher/pattern/match_result.rb#2
class Guard::Watcher
  extend ::Guard::Deprecated::Watcher::ClassMethods

  # Initializes a file watcher.
  #
  # @param pattern [String, Regexp] the pattern to be watched by the Guard
  #   plugin
  # @param action [Block] the action to execute before passing the result to
  #   the Guard plugin
  # @return [Watcher] a new instance of Watcher
  #
  # source://guard//lib/guard/watcher.rb#24
  def initialize(pattern, action = T.unsafe(nil)); end

  # Compare with other watcher
  #
  # @param other [Guard::Watcher] other watcher for comparing
  # @return [true, false] equal or not
  #
  # source://guard//lib/guard/watcher.rb#32
  def ==(other); end

  # Returns the value of attribute action.
  #
  # source://guard//lib/guard/watcher.rb#15
  def action; end

  # Sets the attribute action
  #
  # @param value the value to set the attribute action to.
  #
  # source://guard//lib/guard/watcher.rb#15
  def action=(_arg0); end

  # Executes a watcher action.
  #
  # @param matches [String, MatchData] the matched path or the match from the
  #   Regex
  # @return [String] the final paths
  #
  # source://guard//lib/guard/watcher.rb#81
  def call_action(matches); end

  # source://guard//lib/guard/watcher.rb#70
  def match(string_or_pathname); end

  # Returns the value of attribute pattern.
  #
  # source://guard//lib/guard/watcher.rb#15
  def pattern; end

  # Sets the attribute pattern
  #
  # @param value the value to set the attribute pattern to.
  #
  # source://guard//lib/guard/watcher.rb#15
  def pattern=(_arg0); end

  class << self
    # Finds the files that matches a Guard plugin.
    #
    # @param guard [Guard::Plugin] the Guard plugin which watchers are used
    # @param files [Array<String>] the changed files
    # @return [Array<Object>] the matched watcher response
    #
    # source://guard//lib/guard/watcher.rb#42
    def match_files(guard, files); end
  end
end

# source://guard//lib/guard/watcher/pattern/match_result.rb#3
class Guard::Watcher::Pattern
  class << self
    # source://guard//lib/guard/watcher/pattern.rb#12
    def create(pattern); end
  end
end

# TODO: remove before Guard 3.x
#
# source://guard//lib/guard/watcher/pattern/deprecated_regexp.rb#7
class Guard::Watcher::Pattern::DeprecatedRegexp
  # @return [DeprecatedRegexp] a new instance of DeprecatedRegexp
  #
  # source://guard//lib/guard/watcher/pattern/deprecated_regexp.rb#8
  def initialize(pattern); end

  # @return [Boolean]
  #
  # source://guard//lib/guard/watcher/pattern/deprecated_regexp.rb#16
  def deprecated?; end

  class << self
    # source://guard//lib/guard/watcher/pattern/deprecated_regexp.rb#12
    def convert(pattern); end

    # source://guard//lib/guard/watcher/pattern/deprecated_regexp.rb#21
    def show_deprecation(pattern); end
  end
end

# source://guard//lib/guard/watcher/pattern/match_result.rb#4
class Guard::Watcher::Pattern::MatchResult
  # @return [MatchResult] a new instance of MatchResult
  #
  # source://guard//lib/guard/watcher/pattern/match_result.rb#5
  def initialize(match_result, original_value); end

  # source://guard//lib/guard/watcher/pattern/match_result.rb#10
  def [](index); end
end

# source://guard//lib/guard/watcher/pattern/matcher.rb#4
class Guard::Watcher::Pattern::Matcher
  # @return [Matcher] a new instance of Matcher
  #
  # source://guard//lib/guard/watcher/pattern/matcher.rb#7
  def initialize(obj); end

  # Compare with other matcher
  #
  # @param other [Guard::Watcher::Pattern::Matcher] other matcher for comparing
  # @return [true, false] equal or not
  #
  # source://guard//lib/guard/watcher/pattern/matcher.rb#15
  def ==(other); end

  # source://guard//lib/guard/watcher/pattern/matcher.rb#19
  def match(string_or_pathname); end

  # Returns the value of attribute matcher.
  #
  # source://guard//lib/guard/watcher/pattern/matcher.rb#5
  def matcher; end

  private

  # source://guard//lib/guard/watcher/pattern/matcher.rb#25
  def normalized(string_or_pathname); end
end

# source://guard//lib/guard/watcher/pattern/pathname_path.rb#6
class Guard::Watcher::Pattern::PathnamePath < ::Guard::Watcher::Pattern::SimplePath
  protected

  # source://guard//lib/guard/watcher/pattern/pathname_path.rb#9
  def normalize(string_or_pathname); end
end

# source://guard//lib/guard/watcher/pattern/simple_path.rb#4
class Guard::Watcher::Pattern::SimplePath
  # @return [SimplePath] a new instance of SimplePath
  #
  # source://guard//lib/guard/watcher/pattern/simple_path.rb#5
  def initialize(string_or_pathname); end

  # source://guard//lib/guard/watcher/pattern/simple_path.rb#9
  def match(string_or_pathname); end

  protected

  # source://guard//lib/guard/watcher/pattern/simple_path.rb#17
  def normalize(string_or_pathname); end
end
