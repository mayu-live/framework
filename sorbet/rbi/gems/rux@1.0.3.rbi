# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rux` gem.
# Please instead update this file by running `bin/tapioca gem rux`.

# source://rux//lib/rux.rb#19
module Rux
  class << self
    # Returns the value of attribute buffer.
    #
    # source://rux//lib/rux.rb#35
    def buffer; end

    # Sets the attribute buffer
    #
    # @param value the value to set the attribute buffer to.
    #
    # source://rux//lib/rux.rb#35
    def buffer=(_arg0); end

    # source://rux//lib/rux.rb#62
    def create_buffer; end

    # source://rux//lib/rux.rb#54
    def default_buffer; end

    # source://rux//lib/rux.rb#50
    def default_tag_builder; end

    # source://rux//lib/rux.rb#46
    def default_visitor; end

    # source://rux//lib/rux.rb#66
    def library_paths; end

    # source://rux//lib/rux.rb#58
    def tag(tag_name, attributes = T.unsafe(nil), &block); end

    # Returns the value of attribute tag_builder.
    #
    # source://rux//lib/rux.rb#35
    def tag_builder; end

    # Sets the attribute tag_builder
    #
    # @param value the value to set the attribute tag_builder to.
    #
    # source://rux//lib/rux.rb#35
    def tag_builder=(_arg0); end

    # source://rux//lib/rux.rb#37
    def to_ruby(str, visitor: T.unsafe(nil), pretty: T.unsafe(nil)); end
  end
end

# source://rux//lib/rux/ast.rb#2
module Rux::AST; end

# source://rux//lib/rux/ast/list_node.rb#3
class Rux::AST::ListNode
  # @return [ListNode] a new instance of ListNode
  #
  # source://rux//lib/rux/ast/list_node.rb#6
  def initialize(children); end

  # source://rux//lib/rux/ast/list_node.rb#10
  def accept(visitor); end

  # Returns the value of attribute children.
  #
  # source://rux//lib/rux/ast/list_node.rb#4
  def children; end
end

# source://rux//lib/rux/ast/ruby_node.rb#3
class Rux::AST::RubyNode
  # @return [RubyNode] a new instance of RubyNode
  #
  # source://rux//lib/rux/ast/ruby_node.rb#6
  def initialize(code); end

  # source://rux//lib/rux/ast/ruby_node.rb#10
  def accept(visitor); end

  # Returns the value of attribute code.
  #
  # source://rux//lib/rux/ast/ruby_node.rb#4
  def code; end
end

# source://rux//lib/rux/ast/string_node.rb#3
class Rux::AST::StringNode
  # @return [StringNode] a new instance of StringNode
  #
  # source://rux//lib/rux/ast/string_node.rb#6
  def initialize(str); end

  # source://rux//lib/rux/ast/string_node.rb#10
  def accept(visitor); end

  # Returns the value of attribute str.
  #
  # source://rux//lib/rux/ast/string_node.rb#4
  def str; end
end

# source://rux//lib/rux/ast/tag_node.rb#3
class Rux::AST::TagNode
  # @return [TagNode] a new instance of TagNode
  #
  # source://rux//lib/rux/ast/tag_node.rb#6
  def initialize(name, attrs); end

  # source://rux//lib/rux/ast/tag_node.rb#12
  def accept(visitor); end

  # Returns the value of attribute attrs.
  #
  # source://rux//lib/rux/ast/tag_node.rb#4
  def attrs; end

  # Returns the value of attribute children.
  #
  # source://rux//lib/rux/ast/tag_node.rb#4
  def children; end

  # Returns the value of attribute name.
  #
  # source://rux//lib/rux/ast/tag_node.rb#4
  def name; end
end

# source://rux//lib/rux/ast/text_node.rb#5
class Rux::AST::TextNode
  # @return [TextNode] a new instance of TextNode
  #
  # source://rux//lib/rux/ast/text_node.rb#8
  def initialize(text); end

  # source://rux//lib/rux/ast/text_node.rb#12
  def accept(visitor); end

  # Returns the value of attribute text.
  #
  # source://rux//lib/rux/ast/text_node.rb#6
  def text; end
end

# source://rux//lib/rux/buffer.rb#2
class Rux::Buffer
  # @return [Buffer] a new instance of Buffer
  #
  # source://rux//lib/rux/buffer.rb#3
  def initialize(init_str = T.unsafe(nil)); end

  # source://rux//lib/rux/buffer.rb#7
  def <<(*obj); end

  # source://rux//lib/rux/buffer.rb#11
  def to_s; end
end

# source://rux//lib/rux/default_tag_builder.rb#2
class Rux::DefaultTagBuilder
  # source://rux//lib/rux/default_tag_builder.rb#3
  def call(tag_name, attributes = T.unsafe(nil)); end

  private

  # source://rux//lib/rux/default_tag_builder.rb#12
  def serialize_attrs(attributes); end
end

# source://rux//lib/rux/default_visitor.rb#4
class Rux::DefaultVisitor < ::Rux::Visitor
  # source://rux//lib/rux/default_visitor.rb#5
  def visit_list(node); end

  # source://rux//lib/rux/default_visitor.rb#9
  def visit_ruby(node); end

  # source://rux//lib/rux/default_visitor.rb#13
  def visit_string(node); end

  # source://rux//lib/rux/default_visitor.rb#17
  def visit_tag(node); end

  # source://rux//lib/rux/default_visitor.rb#63
  def visit_text(node); end
end

# source://rux//lib/rux/file.rb#2
class Rux::File
  # @return [File] a new instance of File
  #
  # source://rux//lib/rux/file.rb#5
  def initialize(path); end

  # source://rux//lib/rux/file.rb#17
  def default_outfile; end

  # Returns the value of attribute path.
  #
  # source://rux//lib/rux/file.rb#3
  def path; end

  # source://rux//lib/rux/file.rb#9
  def to_ruby(visitor: T.unsafe(nil), **kwargs); end

  # source://rux//lib/rux/file.rb#13
  def write(outfile = T.unsafe(nil), **kwargs); end

  private

  # source://rux//lib/rux/file.rb#23
  def contents; end
end

# source://rux//lib/rux/lex.rb#2
module Rux::Lex; end

# source://rux//lib/rux/lex/patterns.rb#9
class Rux::Lex::CharsetPattern
  # @return [CharsetPattern] a new instance of CharsetPattern
  #
  # source://rux//lib/rux/lex/patterns.rb#26
  def initialize(chars); end

  # Returns the value of attribute chars.
  #
  # source://rux//lib/rux/lex/patterns.rb#24
  def chars; end

  # @return [Boolean]
  #
  # source://rux//lib/rux/lex/patterns.rb#30
  def matches?(char); end

  class << self
    # source://rux//lib/rux/lex/patterns.rb#10
    def parse(str); end
  end
end

# source://rux//lib/rux/lex/patterns.rb#3
class Rux::Lex::DefaultPattern
  # @return [Boolean]
  #
  # source://rux//lib/rux/lex/patterns.rb#4
  def matches?(_); end
end

# source://rux//lib/rux/lex/patterns.rb#35
class Rux::Lex::NegatedCharsetPattern < ::Rux::Lex::CharsetPattern
  # @return [Boolean]
  #
  # source://rux//lib/rux/lex/patterns.rb#36
  def matches?(char); end
end

# source://rux//lib/rux/lex/state.rb#3
class Rux::Lex::State
  # @return [State] a new instance of State
  #
  # source://rux//lib/rux/lex/state.rb#19
  def initialize(name, is_terminal, transitions); end

  # source://rux//lib/rux/lex/state.rb#26
  def [](chr); end

  # Returns the value of attribute is_terminal.
  #
  # source://rux//lib/rux/lex/state.rb#15
  def is_terminal; end

  # Returns the value of attribute name.
  #
  # source://rux//lib/rux/lex/state.rb#15
  def name; end

  # Returns the value of attribute is_terminal.
  #
  # source://rux//lib/rux/lex/state.rb#15
  def terminal?; end

  # Returns the value of attribute transitions.
  #
  # source://rux//lib/rux/lex/state.rb#15
  def transitions; end

  class << self
    # source://rux//lib/rux/lex/state.rb#4
    def parse(state_str, transition_strs, inputs); end
  end
end

# source://rux//lib/rux/lex/transition.rb#3
class Rux::Lex::Transition
  # @return [Transition] a new instance of Transition
  #
  # source://rux//lib/rux/lex/transition.rb#11
  def initialize(input, to_state, advance_count); end

  # Returns the value of attribute advance_count.
  #
  # source://rux//lib/rux/lex/transition.rb#4
  def advance_count; end

  # Returns the value of attribute input.
  #
  # source://rux//lib/rux/lex/transition.rb#4
  def input; end

  # @return [Boolean]
  #
  # source://rux//lib/rux/lex/transition.rb#17
  def matches?(chr); end

  # Returns the value of attribute to_state.
  #
  # source://rux//lib/rux/lex/transition.rb#4
  def to_state; end

  class << self
    # source://rux//lib/rux/lex/transition.rb#6
    def parse(str, input); end
  end
end

# source://rux//lib/rux/lexer.rb#2
class Rux::Lexer
  # @return [Lexer] a new instance of Lexer
  #
  # source://rux//lib/rux/lexer.rb#8
  def initialize(source_buffer); end

  # source://rux//lib/rux/lexer.rb#14
  def advance; end

  # Returns the value of attribute source_buffer.
  #
  # source://rux//lib/rux/lexer.rb#6
  def source_buffer; end

  private

  # source://rux//lib/rux/lexer.rb#60
  def current; end

  # source://rux//lib/rux/lexer.rb#22
  def each_token; end
end

# source://rux//lib/rux/lexer.rb#3
class Rux::Lexer::EOFError < ::StandardError; end

# source://rux//lib/rux/lexer.rb#4
class Rux::Lexer::TransitionError < ::StandardError; end

# source://rux//lib/rux/parser.rb#4
class Rux::Parser
  # @return [Parser] a new instance of Parser
  #
  # source://rux//lib/rux/parser.rb#22
  def initialize(lexer); end

  # source://rux//lib/rux/parser.rb#28
  def parse; end

  private

  # source://rux//lib/rux/parser.rb#172
  def attr_ruby_code; end

  # source://rux//lib/rux/parser.rb#145
  def attribute; end

  # source://rux//lib/rux/parser.rb#162
  def attribute_value; end

  # source://rux//lib/rux/parser.rb#134
  def attributes; end

  # source://rux//lib/rux/parser.rb#219
  def consume(*types); end

  # source://rux//lib/rux/parser.rb#202
  def current; end

  # source://rux//lib/rux/parser.rb#240
  def get_next; end

  # @return [Boolean]
  #
  # source://rux//lib/rux/parser.rb#206
  def is?(*types); end

  # source://rux//lib/rux/parser.rb#180
  def literal; end

  # source://rux//lib/rux/parser.rb#194
  def literal_ruby_code; end

  # source://rux//lib/rux/parser.rb#210
  def maybe_consume(type); end

  # source://rux//lib/rux/parser.rb#236
  def pos_of(token); end

  # source://rux//lib/rux/parser.rb#61
  def ruby; end

  # source://rux//lib/rux/parser.rb#190
  def squeeze_lit(lit); end

  # source://rux//lib/rux/parser.rb#87
  def tag; end

  # source://rux//lib/rux/parser.rb#232
  def text_of(token); end

  # source://rux//lib/rux/parser.rb#228
  def type_of(token); end

  class << self
    # source://rux//lib/rux/parser.rb#15
    def parse(str); end

    # source://rux//lib/rux/parser.rb#9
    def parse_file(path); end
  end
end

# source://rux//lib/rux/parser.rb#6
class Rux::Parser::TagMismatchError < ::StandardError; end

# source://rux//lib/rux/parser.rb#5
class Rux::Parser::UnexpectedTokenError < ::StandardError; end

# source://rux//lib/rux/ruby_lexer.rb#4
class Rux::RubyLexer < ::Parser::Lexer
  # @return [RubyLexer] a new instance of RubyLexer
  #
  # source://rux//lib/rux/ruby_lexer.rb#11
  def initialize(source_buffer, init_pos); end

  # source://rux//lib/rux/ruby_lexer.rb#22
  def advance; end

  # source://parser/3.1.2.1/lib/parser/lexer.rb#11303
  def advance_orig; end

  # source://rux//lib/rux/ruby_lexer.rb#33
  def next_lexer(pos); end

  # source://rux//lib/rux/ruby_lexer.rb#26
  def reset_to(pos); end

  private

  # @return [Boolean]
  #
  # source://rux//lib/rux/ruby_lexer.rb#125
  def at_inheritance?; end

  # @return [Boolean]
  #
  # source://rux//lib/rux/ruby_lexer.rb#118
  def at_lt?; end

  # @return [Boolean]
  #
  # source://rux//lib/rux/ruby_lexer.rb#114
  def at_rux?; end

  # source://rux//lib/rux/ruby_lexer.rb#46
  def each_token(&block); end

  # @return [Boolean]
  #
  # source://rux//lib/rux/ruby_lexer.rb#131
  def is?(tok, sym); end

  # @return [Boolean]
  #
  # source://rux//lib/rux/ruby_lexer.rb#135
  def is_not?(tok, sym); end

  # source://rux//lib/rux/ruby_lexer.rb#139
  def make_range(start, stop); end

  # source://rux//lib/rux/ruby_lexer.rb#97
  def populate_queue; end

  # source://rux//lib/rux/ruby_lexer.rb#39
  def ruby_version; end
end

# source://rux//lib/rux/ruby_lexer.rb#9
Rux::RubyLexer::LOOKAHEAD = T.let(T.unsafe(nil), Integer)

# source://rux//lib/rux/rux_lexer.rb#4
class Rux::RuxLexer
  # @return [RuxLexer] a new instance of RuxLexer
  #
  # source://rux//lib/rux/rux_lexer.rb#44
  def initialize(source_buffer, init_pos); end

  # source://rux//lib/rux/rux_lexer.rb#51
  def advance; end

  # source://rux//lib/rux/rux_lexer.rb#60
  def next_lexer(pos); end

  # source://rux//lib/rux/rux_lexer.rb#55
  def reset_to(pos); end

  private

  # source://rux//lib/rux/rux_lexer.rb#139
  def check_eof; end

  # source://rux//lib/rux/rux_lexer.rb#101
  def each_rux_token(&block); end

  # source://rux//lib/rux/rux_lexer.rb#66
  def each_token; end

  # source://rux//lib/rux/rux_lexer.rb#145
  def make_range(start, stop); end

  # Ruby code can only exist in two places: attribute values and inside tag
  # bodies. Eventually I'd like to also allow passing a Ruby hash to
  # dynamically specify attributes, but we're not there yet.
  #
  # @return [Boolean]
  #
  # source://rux//lib/rux/rux_lexer.rb#152
  def ruby_code?(state); end

  class << self
    # source://rux//lib/rux/rux_lexer.rb#30
    def parse_pattern(pattern); end

    # See: https://docs.google.com/spreadsheets/d/11ikKuySIKoaj-kFIfhlzebUwH31cRt_1flGjWfk7RMg
    #
    # source://rux//lib/rux/rux_lexer.rb#7
    def state_table; end

    # source://rux//lib/rux/rux_lexer.rb#25
    def state_table_path; end
  end
end

# source://rux//lib/rux/utils.rb#2
module Rux::Utils
  extend ::Rux::Utils

  # source://rux//lib/rux/utils.rb#3
  def attr_to_hash_elem(key, value); end
end

# source://rux//lib/rux/visitor.rb#2
class Rux::Visitor
  # source://rux//lib/rux/visitor.rb#3
  def visit(node); end

  # source://rux//lib/rux/visitor.rb#27
  def visit_children(node); end

  # source://rux//lib/rux/visitor.rb#7
  def visit_list(node); end

  # source://rux//lib/rux/visitor.rb#11
  def visit_ruby(node); end

  # source://rux//lib/rux/visitor.rb#15
  def visit_string(node); end

  # source://rux//lib/rux/visitor.rb#19
  def visit_tag(node); end

  # source://rux//lib/rux/visitor.rb#23
  def visit_text(node); end
end
