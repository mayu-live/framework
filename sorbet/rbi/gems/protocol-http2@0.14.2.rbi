# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http2` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http2`.

# source://protocol-http2//lib/protocol/http2/error.rb#23
module Protocol; end

# source://protocol-http2//lib/protocol/http2/error.rb#24
module Protocol::HTTP2; end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#25
Protocol::HTTP2::ACKNOWLEDGEMENT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#27
module Protocol::HTTP2::Acknowledgement
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#32
  def acknowledge; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#28
  def acknowledgement?; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#33
Protocol::HTTP2::CANCEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#34
Protocol::HTTP2::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# Default connection "fast-fail" preamble string as defined by the spec.
#
# source://protocol-http2//lib/protocol/http2/framer.rb#52
Protocol::HTTP2::CONNECTION_PREFACE_MAGIC = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#35
Protocol::HTTP2::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/client.rb#25
class Protocol::HTTP2::Client < ::Protocol::HTTP2::Connection
  # @return [Client] a new instance of Client
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#26
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#58
  def create_push_promise_stream; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#30
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#62
  def receive_push_promise(frame); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#34
  def remote_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/client.rb#42
  def send_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/client.rb#38
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/connection.rb#29
class Protocol::HTTP2::Connection
  include ::Protocol::HTTP2::FlowControlled

  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#32
  def initialize(framer, local_stream_id); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#66
  def [](id); end

  # Accept an incoming push promise from the other side of the connection.
  # On the client side, we accept push promise streams.
  # On the server side, existing streams create push promise streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#347
  def accept_push_promise_stream(stream_id, &block); end

  # Accept an incoming stream from the other side of the connnection.
  # On the server side, we accept requests.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#336
  def accept_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#430
  def client_stream_id?(id); end

  # Close the underlying framer and all streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#113
  def close(error = T.unsafe(nil)); end

  # Transition the connection into the closed state.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#194
  def close!; end

  # Whether the connection is effectively or actually closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#103
  def closed?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#438
  def closed_stream_id?(id); end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#473
  def consume_window(size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#362
  def create_push_promise_stream(&block); end

  # Create a stream, defaults to an outgoing stream.
  # On the client side, we create requests.
  #
  # @return [Stream] the created stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#354
  def create_stream(id = T.unsafe(nil), &block); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#128
  def decode_headers(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#107
  def delete(id); end

  # Returns the value of attribute dependencies.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#143
  def dependencies; end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#145
  def dependency; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#124
  def encode_headers(headers, buffer = T.unsafe(nil)); end

  # Returns the value of attribute framer.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#83
  def framer; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#62
  def id; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#399
  def idle_stream_id?(id); end

  # 6.8. GOAWAY
  # There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.
  # Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#150
  def ignore_frame?(frame); end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#89
  def local_settings; end

  # Current settings value for local and peer
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#89
  def local_settings=(_arg0); end

  # Our window for receiving data. When we receive data, it reduces this window.
  # If the window gets too small, we must send a window update.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#94
  def local_window; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#79
  def maximum_concurrent_streams; end

  # The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#75
  def maximum_frame_size; end

  # Streams are identified with an unsigned 31-bit integer.  Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers.  A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#133
  def next_stream_id; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#274
  def open!; end

  # In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the "open" or "half-closed (remote)" state).  When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # @return [Boolean] whether the frame was an acknowledgement
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#251
  def process_settings(frame); end

  # Reads one frame from the network and processes. Processing the frame updates the state of the connection and related streams. If the frame triggers an error, e.g. a protocol error, the connection will typically emit a goaway frame and re-raise the exception. You should continue processing frames until the underlying connection is closed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#160
  def read_frame; end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#509
  def receive_continuation(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#318
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#513
  def receive_frame(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#210
  def receive_goaway(frame); end

  # On the server side, starts a new request.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#367
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#302
  def receive_ping(frame); end

  # Sets the priority for an incoming stream.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#418
  def receive_priority(frame); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#426
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#459
  def receive_reset_stream(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#280
  def receive_settings(frame); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#490
  def receive_window_update(frame); end

  # Returns the value of attribute remote_settings.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#90
  def remote_settings; end

  # Sets the attribute remote_settings
  #
  # @param value the value to set the attribute remote_settings to.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#90
  def remote_settings=(_arg0); end

  # The highest stream_id that has been successfully accepted by this connection.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#100
  def remote_stream_id; end

  # Our window for sending data. When we send data, it reduces this window.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#97
  def remote_window; end

  # Tell the remote end that the connection is being shut down. If the `error_code` is 0, this is a graceful shutdown. The other end of the connection should not make any new streams, but existing streams may be completed.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#201
  def send_goaway(error_code = T.unsafe(nil), message = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#291
  def send_ping(data); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#392
  def send_priority(stream_id, priority); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#184
  def send_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#434
  def server_stream_id?(id); end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#86
  def state; end

  # Connection state (:new, :open, :closed).
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#86
  def state=(_arg0); end

  # Returns the value of attribute streams.
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#141
  def streams; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#230
  def update_local_settings(changes); end

  # source://protocol-http2//lib/protocol/http2/connection.rb#240
  def update_remote_settings(changes); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#330
  def valid_remote_stream_id?; end

  # source://protocol-http2//lib/protocol/http2/connection.rb#222
  def write_frame(frame); end

  # @yield [@framer]
  #
  # source://protocol-http2//lib/protocol/http2/connection.rb#226
  def write_frames; end
end

# The CONTINUATION frame is used to continue a sequence of header block fragments. Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.
#
# +---------------------------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#104
class Protocol::HTTP2::ContinuationFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Continued

  # This is only invoked if the continuation is received out of the normal flow.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#110
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#114
  def inspect; end
end

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#107
Protocol::HTTP2::ContinuationFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/continuation_frame.rb#25
module Protocol::HTTP2::Continued
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#26
  def initialize(*_arg0); end

  # Returns the value of attribute continuation.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#66
  def continuation; end

  # Sets the attribute continuation
  #
  # @param value the value to set the attribute continuation to.
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#66
  def continuation=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#32
  def end_headers?; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#68
  def pack(data, **options); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#36
  def read(stream, maximum_frame_size); end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#89
  def unpack; end

  # source://protocol-http2//lib/protocol/http2/continuation_frame.rb#58
  def write(stream); end
end

# source://protocol-http2//lib/protocol/http2/dependency.rb#23
Protocol::HTTP2::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

# DATA frames convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.
#
# DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages.
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/data_frame.rb#39
class Protocol::HTTP2::DataFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#57
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/data_frame.rb#44
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#61
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/data_frame.rb#48
  def pack(data, *arguments, **options); end
end

# source://protocol-http2//lib/protocol/http2/data_frame.rb#42
Protocol::HTTP2::DataFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/dependency.rb#25
class Protocol::HTTP2::Dependency
  # @return [Dependency] a new instance of Dependency
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#55
  def initialize(connection, id, weight = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#72
  def <=>(other); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#113
  def add_child(dependency); end

  # The dependent children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#86
  def children; end

  # The dependent children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#86
  def children=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#95
  def clear_cache!; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#77
  def connection; end

  # Traverse active streams in order of priority and allow them to consume the available flow-control window.
  #
  # @param amount [Integer] the amount of data to write. Defaults to the current window capacity.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#206
  def consume_window(size); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#99
  def delete!; end

  # An exclusive flag allows for the insertion of a new level of dependencies.  The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream.
  #
  # @param parent [Dependency] the dependency which will be inserted, taking control of all current children.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#130
  def exclusive_child(parent); end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#80
  def id; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#193
  def ordered_children; end

  # The parent dependency.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#83
  def parent; end

  # The parent dependency.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#83
  def parent=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#225
  def print_hierarchy(buffer, indent: T.unsafe(nil)); end

  # The current local priority of the stream.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#175
  def priority(exclusive = T.unsafe(nil)); end

  # Change the priority of the stream both locally and remotely.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#169
  def priority=(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#145
  def process_priority(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#183
  def receive_priority(frame); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#122
  def remove_child(dependency); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#179
  def send_priority(priority); end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#91
  def stream; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#221
  def to_s; end

  # source://protocol-http2//lib/protocol/http2/dependency.rb#187
  def total_weight; end

  # The weight of the stream relative to other siblings.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#89
  def weight; end

  # The weight of the stream relative to other siblings.
  #
  # source://protocol-http2//lib/protocol/http2/dependency.rb#89
  def weight=(_arg0); end

  class << self
    # source://protocol-http2//lib/protocol/http2/dependency.rb#26
    def create(connection, id, priority = T.unsafe(nil)); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#27
Protocol::HTTP2::END_HEADERS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#26
Protocol::HTTP2::END_STREAM = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#36
Protocol::HTTP2::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# Status codes as defined by <https://tools.ietf.org/html/rfc7540#section-7>.
#
# source://protocol-http2//lib/protocol/http2/error.rb#27
class Protocol::HTTP2::Error < ::Protocol::HTTP::Error; end

# Used by the endpoint to indicate that the stream is no longer needed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#52
Protocol::HTTP2::Error::CANCEL = T.let(T.unsafe(nil), Integer)

# The endpoint is unable to maintain the header compression context for the connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#55
Protocol::HTTP2::Error::COMPRESSION_ERROR = T.let(T.unsafe(nil), Integer)

# The connection established in response to a CONNECT request was reset or abnormally closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#58
Protocol::HTTP2::Error::CONNECT_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.
#
# source://protocol-http2//lib/protocol/http2/error.rb#61
Protocol::HTTP2::Error::ENHANCE_YOUR_CALM = T.let(T.unsafe(nil), Integer)

# The endpoint detected that its peer violated the flow-control protocol.
#
# source://protocol-http2//lib/protocol/http2/error.rb#37
Protocol::HTTP2::Error::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame with an invalid size.
#
# source://protocol-http2//lib/protocol/http2/error.rb#46
Protocol::HTTP2::Error::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint requires that HTTP/1.1 be used instead of HTTP/2.
#
# source://protocol-http2//lib/protocol/http2/error.rb#67
Protocol::HTTP2::Error::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# The underlying transport has properties that do not meet minimum security requirements.
#
# source://protocol-http2//lib/protocol/http2/error.rb#64
Protocol::HTTP2::Error::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# The endpoint encountered an unexpected internal error.
#
# source://protocol-http2//lib/protocol/http2/error.rb#34
Protocol::HTTP2::Error::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# The associated condition is not a result of an error.  For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.
#
# source://protocol-http2//lib/protocol/http2/error.rb#28
Protocol::HTTP2::Error::NO_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint detected an unspecific protocol error.  This error is for use when a more specific error code is not available.
#
# source://protocol-http2//lib/protocol/http2/error.rb#31
Protocol::HTTP2::Error::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# The endpoint refused the stream prior to performing any application processing.
#
# source://protocol-http2//lib/protocol/http2/error.rb#49
Protocol::HTTP2::Error::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The endpoint sent a SETTINGS frame but did not receive a response in a timely manner.
#
# source://protocol-http2//lib/protocol/http2/error.rb#40
Protocol::HTTP2::Error::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# The endpoint received a frame after a stream was half-closed.
#
# source://protocol-http2//lib/protocol/http2/error.rb#43
Protocol::HTTP2::Error::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#28
Protocol::HTTP2::FLOW_CONTROL_ERROR = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
#
# source://protocol-http2//lib/protocol/http2/framer.rb#38
Protocol::HTTP2::FRAMES = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#31
Protocol::HTTP2::FRAME_SIZE_ERROR = T.let(T.unsafe(nil), Integer)

# Raised on invalid flow control frame or command.
#
# source://protocol-http2//lib/protocol/http2/error.rb#115
class Protocol::HTTP2::FlowControlError < ::Protocol::HTTP2::ProtocolError
  # @return [FlowControlError] a new instance of FlowControlError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#116
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/flow_controlled.rb#25
module Protocol::HTTP2::FlowControlled
  # This could be negative if the window has been overused due to a change in initial window size.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#31
  def available_frame_size(maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#26
  def available_size; end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#62
  def consume_local_window(frame); end

  # Keep track of the amount of data sent, and fail if is too much.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#44
  def consume_remote_window(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#84
  def receive_window_update(frame); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#68
  def request_window_update; end

  # Notify the remote end that we are prepared to receive more data:
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#75
  def send_window_update(window_increment); end

  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#57
  def update_local_window(frame); end

  # The window has been expanded by the given amount.
  #
  # @param size [Integer] the maximum amount of data to send.
  # @return [Boolean] whether the window update was used or not.
  #
  # source://protocol-http2//lib/protocol/http2/flow_controlled.rb#101
  def window_updated(size); end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#35
class Protocol::HTTP2::Frame
  include ::Comparable

  # @param length [Integer] the length of the payload, or nil if the header has not been read yet.
  # @return [Frame] a new instance of Frame
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#50
  def initialize(stream_id = T.unsafe(nil), flags = T.unsafe(nil), type = T.unsafe(nil), length = T.unsafe(nil), payload = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#62
  def <=>(other); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#204
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#105
  def clear_flags(mask); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#117
  def connection?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#109
  def flag_set?(mask); end

  # Returns the value of attribute flags.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#84
  def flags; end

  # Sets the attribute flags
  #
  # @param value the value to set the attribute flags to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#84
  def flags=(_arg0); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @return [String]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#128
  def header; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#208
  def inspect; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#82
  def length; end

  # The generic frame header uses the following binary representation:
  #
  # +-----------------------------------------------+
  # |                 Length (24)                   |
  # +---------------+---------------+---------------+
  # |   Type (8)    |   Flags (8)   |
  # +-+-------------+---------------+-------------------------------+
  # |R|                 Stream Identifier (31)                      |
  # +=+=============================================================+
  # |                   Frame Payload (0...)                      ...
  # +---------------------------------------------------------------+
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#82
  def length=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#92
  def pack(payload, maximum_size: T.unsafe(nil)); end

  # Returns the value of attribute payload.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#86
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#86
  def payload=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#177
  def read(stream, maximum_frame_size = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#160
  def read_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#169
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#101
  def set_flags(mask); end

  # Returns the value of attribute stream_id.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#85
  def stream_id; end

  # Sets the attribute stream_id
  #
  # @param value the value to set the attribute stream_id to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#85
  def stream_id=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#66
  def to_ary; end

  # Returns the value of attribute type.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#83
  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#83
  def type=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#88
  def unpack; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/frame.rb#58
  def valid_type?; end

  # source://protocol-http2//lib/protocol/http2/frame.rb#195
  def write(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#187
  def write_header(stream); end

  # source://protocol-http2//lib/protocol/http2/frame.rb#191
  def write_payload(stream); end

  class << self
    # Decodes common 9-byte header.
    #
    # @param buffer [String]
    #
    # source://protocol-http2//lib/protocol/http2/frame.rb#150
    def parse_header(buffer); end
  end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#121
Protocol::HTTP2::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)

# Used for generating 24-bit frame length:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#46
Protocol::HTTP2::Frame::LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#47
Protocol::HTTP2::Frame::LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#122
Protocol::HTTP2::Frame::STREAM_ID_MASK = T.let(T.unsafe(nil), Integer)

# The absolute maximum bounds for the length field:
#
# source://protocol-http2//lib/protocol/http2/frame.rb#43
Protocol::HTTP2::Frame::VALID_LENGTH = T.let(T.unsafe(nil), Range)

# Stream Identifier cannot be bigger than this:
# https://http2.github.stream/http2-spec/#rfc.section.4.1
#
# source://protocol-http2//lib/protocol/http2/frame.rb#40
Protocol::HTTP2::Frame::VALID_STREAM_ID = T.let(T.unsafe(nil), Range)

# When the frame payload does not match expectations.
#
# source://protocol-http2//lib/protocol/http2/error.rb#108
class Protocol::HTTP2::FrameSizeError < ::Protocol::HTTP2::ProtocolError
  # @return [FrameSizeError] a new instance of FrameSizeError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#109
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/framer.rb#54
class Protocol::HTTP2::Framer
  # @return [Framer] a new instance of Framer
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#55
  def initialize(stream, frames = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/framer.rb#60
  def close; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#64
  def closed?; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#72
  def read_connection_preface; end

  # @raise if the underlying IO fails for some reason.
  # @return [Frame] the frame that has been read from the underlying IO.
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#84
  def read_frame(maximum_frame_size = T.unsafe(nil)); end

  # @raise [EOFError]
  #
  # source://protocol-http2//lib/protocol/http2/framer.rb#113
  def read_header; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#68
  def write_connection_preface; end

  # source://protocol-http2//lib/protocol/http2/framer.rb#102
  def write_frame(frame); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#104
class Protocol::HTTP2::GoawayError < ::Protocol::HTTP2::ProtocolError; end

# The GOAWAY frame is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.
#
# +-+-------------------------------------------------------------+
# |R|                  Last-Stream-ID (31)                        |
# +-+-------------------------------------------------------------+
# |                      Error Code (32)                          |
# +---------------------------------------------------------------+
# |                  Additional Debug Data (*)                    |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#35
class Protocol::HTTP2::GoawayFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#55
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#39
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#51
  def pack(last_stream_id, error_code, data); end

  # source://protocol-http2//lib/protocol/http2/goaway_frame.rb#43
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#37
Protocol::HTTP2::GoawayFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/goaway_frame.rb#36
Protocol::HTTP2::GoawayFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#38
Protocol::HTTP2::HTTP_1_1_REQUIRED = T.let(T.unsafe(nil), Integer)

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
#
# source://protocol-http2//lib/protocol/http2/error.rb#73
class Protocol::HTTP2::HandshakeError < ::Protocol::HTTP2::Error; end

# source://protocol-http2//lib/protocol/http2/error.rb#98
class Protocol::HTTP2::HeaderError < ::Protocol::HTTP2::StreamClosed
  # @return [HeaderError] a new instance of HeaderError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#99
  def initialize(message); end
end

# The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |E|                 Stream Dependency? (31)                     |
# +-+-------------+-----------------------------------------------+
# |  Weight? (8)  |
# +-+-------------+-----------------------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/headers_frame.rb#42
class Protocol::HTTP2::HeadersFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#81
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#51
  def end_stream?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#85
  def inspect; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#66
  def pack(priority, data, *arguments, **options); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#47
  def priority?; end

  # source://protocol-http2//lib/protocol/http2/headers_frame.rb#55
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/headers_frame.rb#45
Protocol::HTTP2::HeadersFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#37
Protocol::HTTP2::INADEQUATE_SECURITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#27
Protocol::HTTP2::INTERNAL_ERROR = T.let(T.unsafe(nil), Integer)

# This is a window which efficiently maintains a desired capacity.
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#86
class Protocol::HTTP2::LocalWindow < ::Protocol::HTTP2::Window
  # @return [LocalWindow] a new instance of LocalWindow
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#87
  def initialize(capacity = T.unsafe(nil), desired: T.unsafe(nil)); end

  # Returns the value of attribute desired.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#93
  def desired; end

  # Sets the attribute desired
  #
  # @param value the value to set the attribute desired to.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#93
  def desired=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#104
  def limited?; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#95
  def wanted; end
end

# source://protocol-http2//lib/protocol/http2/frame.rb#33
Protocol::HTTP2::MAXIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#31
Protocol::HTTP2::MAXIMUM_ALLOWED_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#32
Protocol::HTTP2::MINIMUM_ALLOWED_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#25
Protocol::HTTP2::NO_ERROR = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#28
Protocol::HTTP2::PADDED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/frame.rb#29
Protocol::HTTP2::PRIORITY = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#26
Protocol::HTTP2::PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)

# Certain frames can have padding:
# https://http2.github.io/http2-spec/#padding
#
# +---------------+
# |Pad Length? (8)|
# +---------------+-----------------------------------------------+
# |                            Data (*)                         ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/padded.rb#37
module Protocol::HTTP2::Padded
  # source://protocol-http2//lib/protocol/http2/padded.rb#42
  def pack(data, padding_size: T.unsafe(nil), maximum_size: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/padded.rb#38
  def padded?; end

  # source://protocol-http2//lib/protocol/http2/padded.rb#63
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#164
class Protocol::HTTP2::PendingSettings
  # @return [PendingSettings] a new instance of PendingSettings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#165
  def initialize(current = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#180
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#175
  def append(changes); end

  # Returns the value of attribute current.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#172
  def current; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#194
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#190
  def header_table_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#202
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#198
  def maximum_concurrent_streams; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#206
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#210
  def maximum_header_list_size; end

  # Returns the value of attribute pending.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#173
  def pending; end
end

# The PING frame is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.
#
# +---------------------------------------------------------------+
# |                                                               |
# |                      Opaque Data (64)                         |
# |                                                               |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/ping_frame.rb#50
class Protocol::HTTP2::PingFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#63
  def acknowledge; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#59
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#55
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/ping_frame.rb#71
  def read_payload(stream); end
end

# source://protocol-http2//lib/protocol/http2/ping_frame.rb#51
Protocol::HTTP2::PingFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Stream Dependency:  A 31-bit stream identifier for the stream that
# this stream depends on (see Section 5.3).  This field is only
# present if the PRIORITY flag is set.
#
# source://protocol-http2//lib/protocol/http2/priority_frame.rb#30
class Protocol::HTTP2::Priority < ::Struct
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#46
  def pack; end

  # Sets the attribute weight
  #
  # @param value [Object] the value to set the attribute weight to.
  # @return [Object] the newly set value
  #
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#56
  def weight=(value); end

  class << self
    # All streams are initially assigned a non-exclusive dependency on stream 0x0.  Pushed streams (Section 8.2) initially depend on their associated stream.  In both cases, streams are assigned a default weight of 16.
    #
    # source://protocol-http2//lib/protocol/http2/priority_frame.rb#35
    def default(stream_dependency = T.unsafe(nil), weight = T.unsafe(nil)); end

    # source://protocol-http2//lib/protocol/http2/priority_frame.rb#39
    def unpack(data); end
  end
end

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#32
Protocol::HTTP2::Priority::EXCLUSIVE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#31
Protocol::HTTP2::Priority::FORMAT = T.let(T.unsafe(nil), String)

# The PRIORITY frame specifies the sender-advised priority of a stream. It can be sent in any stream state, including idle or closed streams.
#
# +-+-------------------------------------------------------------+
# |E|                  Stream Dependency (31)                     |
# +-+-------------+-----------------------------------------------+
# |   Weight (8)  |
# +-+-------------+
#
# source://protocol-http2//lib/protocol/http2/priority_frame.rb#73
class Protocol::HTTP2::PriorityFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#88
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#80
  def pack(priority); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#76
  def priority; end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#92
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/priority_frame.rb#84
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#74
Protocol::HTTP2::PriorityFrame::TYPE = T.let(T.unsafe(nil), Integer)

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
#
# source://protocol-http2//lib/protocol/http2/error.rb#79
class Protocol::HTTP2::ProtocolError < ::Protocol::HTTP2::Error
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#80
  def initialize(message, code = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#86
  def code; end
end

# The PUSH_PROMISE frame is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream.
#
# +---------------+
# |Pad Length? (8)|
# +-+-------------+-----------------------------------------------+
# |R|                  Promised Stream ID (31)                    |
# +-+-----------------------------+-------------------------------+
# |                   Header Block Fragment (*)                 ...
# +---------------------------------------------------------------+
# |                           Padding (*)                       ...
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#39
class Protocol::HTTP2::PushPromiseFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Padded
  include ::Protocol::HTTP2::Continued

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#57
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#53
  def pack(stream_id, data, *arguments, **options); end

  # source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#45
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#43
Protocol::HTTP2::PushPromiseFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/push_promise_frame.rb#42
Protocol::HTTP2::PushPromiseFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#32
Protocol::HTTP2::REFUSED_STREAM = T.let(T.unsafe(nil), Integer)

# The RST_STREAM frame allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.
#
# +---------------------------------------------------------------+
# |                        Error Code (32)                        |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#46
class Protocol::HTTP2::ResetStreamFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#59
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#54
  def pack(error_code = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#63
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#50
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#48
Protocol::HTTP2::ResetStreamFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#47
Protocol::HTTP2::ResetStreamFrame::TYPE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#30
Protocol::HTTP2::STREAM_CLOSED = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/server.rb#25
class Protocol::HTTP2::Server < ::Protocol::HTTP2::Connection
  # @return [Server] a new instance of Server
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#26
  def initialize(framer); end

  # @raise [ProtocolError]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#56
  def accept_push_promise_stream(stream_id, &block); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#60
  def enable_push?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#30
  def local_stream_id?(id); end

  # source://protocol-http2//lib/protocol/http2/server.rb#42
  def read_connection_preface(settings = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#34
  def remote_stream_id?(id); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/server.rb#38
  def valid_remote_stream_id?(stream_id); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#25
class Protocol::HTTP2::Settings
  # @return [Settings] a new instance of Settings
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#97
  def initialize; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#129
  def difference(other); end

  # Returns the value of attribute enable_connect_protocol.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#83
  def enable_connect_protocol; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#85
  def enable_connect_protocol=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#93
  def enable_connect_protocol?; end

  # This setting can be used to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#38
  def enable_push; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#40
  def enable_push=(value); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#48
  def enable_push?; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#35
  def header_table_size; end

  # Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#35
  def header_table_size=(_arg0); end

  # Indicates the sender's initial window size (in octets) for stream-level flow control.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#56
  def initial_window_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#58
  def initial_window_size=(value); end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#53
  def maximum_concurrent_streams; end

  # Indicates the maximum number of concurrent streams that the sender will allow.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#53
  def maximum_concurrent_streams=(_arg0); end

  # Indicates the size of the largest frame payload that the sender is willing to receive, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#68
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#70
  def maximum_frame_size=(value); end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#81
  def maximum_header_list_size; end

  # This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets.
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#81
  def maximum_header_list_size=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#121
  def update(changes); end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#109
Protocol::HTTP2::Settings::ASSIGN = T.let(T.unsafe(nil), Array)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#32
Protocol::HTTP2::Settings::ENABLE_CONNECT_PROTOCOL = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#27
Protocol::HTTP2::Settings::ENABLE_PUSH = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#26
Protocol::HTTP2::Settings::HEADER_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#29
Protocol::HTTP2::Settings::INITIAL_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#28
Protocol::HTTP2::Settings::MAXIMUM_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#30
Protocol::HTTP2::Settings::MAXIMUM_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#31
Protocol::HTTP2::Settings::MAXIMUM_HEADER_LIST_SIZE = T.let(T.unsafe(nil), Integer)

# The SETTINGS frame conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a "setting".
#
# +-------------------------------+
# |       Identifier (16)         |
# +-------------------------------+-------------------------------+
# |                        Value (32)                             |
# +---------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/settings_frame.rb#223
class Protocol::HTTP2::SettingsFrame < ::Protocol::HTTP2::Frame
  include ::Protocol::HTTP2::Acknowledgement

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#246
  def apply(connection); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#229
  def connection?; end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#242
  def pack(settings = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#250
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/settings_frame.rb#233
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#225
Protocol::HTTP2::SettingsFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/settings_frame.rb#224
Protocol::HTTP2::SettingsFrame::TYPE = T.let(T.unsafe(nil), Integer)

# A single HTTP 2.0 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
#                          +--------+
#                  send PP |        | recv PP
#                 ,--------|  idle  |--------.
#                /         |        |         \
#               v          +--------+          v
#        +----------+          |           +----------+
#        |          |          | send H /  |          |
# ,------| reserved |          | recv H    | reserved |------.
# |      | (local)  |          |           | (remote) |      |
# |      +----------+          v           +----------+      |
# |          |             +--------+             |          |
# |          |     recv ES |        | send ES     |          |
# |   send H |     ,-------|  open  |-------.     | recv H   |
# |          |    /        |        |        \    |          |
# |          v   v         +--------+         v   v          |
# |      +----------+          |           +----------+      |
# |      |   half   |          |           |   half   |      |
# |      |  closed  |          | send R /  |  closed  |      |
# |      | (remote) |          | recv R    | (local)  |      |
# |      +----------+          |           +----------+      |
# |           |                |                 |           |
# |           | send ES /      |       recv ES / |           |
# |           | send R /       v        send R / |           |
# |           | recv R     +--------+   recv R   |           |
# | send R /  `----------->|        |<-----------'  send R / |
# | recv R                 | closed |               recv R   |
# `----------------------->|        |<----------------------'
#                          +--------+
#
#    send:   endpoint sends this frame
#    recv:   endpoint receives this frame
#
#    H:  HEADERS frame (with implied CONTINUATIONs)
#    PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
#    ES: END_STREAM flag
#    R:  RST_STREAM frame
#
# State transition methods use a trailing "!".
#
# source://protocol-http2//lib/protocol/http2/stream.rb#74
class Protocol::HTTP2::Stream
  include ::Protocol::HTTP2::FlowControlled

  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#85
  def initialize(connection, id, state = T.unsafe(nil)); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#433
  def accept_push_promise_stream(stream_id, headers); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#135
  def active?; end

  # Transition directly to closed state. Do not pass go, do not collect $200.
  # This method should only be used by `Connection#close`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#145
  def close(error = T.unsafe(nil)); end

  # Transition the stream into the closed state.
  #
  # @param error_code [Integer] the error code if the stream was closed due to a stream reset.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#258
  def close!(error_code = T.unsafe(nil)); end

  # The stream has been closed. If closed due to a stream reset, the error will be set.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#253
  def closed(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#139
  def closed?; end

  # The connection this stream belongs to.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#98
  def connection; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#201
  def consume_remote_window(frame); end

  # Override this function to implement your own push promise logic.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#413
  def create_push_promise_stream(headers); end

  # Returns the value of attribute dependency.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#106
  def dependency; end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#101
  def id; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#336
  def ignore_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#448
  def inspect; end

  # Returns the value of attribute local_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#108
  def local_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#127
  def maximum_frame_size; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#240
  def open!; end

  # The stream has been opened.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#237
  def opened(error = T.unsafe(nil)); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#123
  def parent=(stream); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#115
  def priority; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#119
  def priority=(priority); end

  # @return [String] the data that was received.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#332
  def process_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#284
  def process_headers(frame); end

  # DATA frames are subject to flow control and can only be sent when a stream is in the "open" or "half-closed (remote)" state.  The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present.  If a DATA frame is received whose stream is not in "open" or "half-closed (local)" state, the recipient MUST respond with a stream error of type STREAM_CLOSED.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#341
  def receive_data(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#299
  def receive_headers(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#437
  def receive_push_promise(frame); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#366
  def receive_reset_stream(frame); end

  # Returns the value of attribute remote_window.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#109
  def remote_window; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#396
  def reserved_local!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#404
  def reserved_remote!; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#218
  def send_data(*arguments, **options); end

  # The HEADERS frame is used to open a stream, and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the "idle", "reserved (local)", "open", or "half-closed (remote)" state.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#171
  def send_headers(*arguments); end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#152
  def send_headers?; end

  # Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.
  #
  # @param headers [Hash] contains a complete set of request header fields that the server attributes to the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#419
  def send_push_promise(headers); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#271
  def send_reset_stream(error_code = T.unsafe(nil)); end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#104
  def state; end

  # Stream state, e.g. `idle`, `closed`.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#104
  def state=(_arg0); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#452
  def to_s; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#111
  def weight; end

  # source://protocol-http2//lib/protocol/http2/stream.rb#131
  def write_frame(frame); end

  protected

  # source://protocol-http2//lib/protocol/http2/stream.rb#295
  def ignore_headers(frame); end

  private

  # source://protocol-http2//lib/protocol/http2/stream.rb#207
  def write_data(data, flags = T.unsafe(nil), **options); end

  # source://protocol-http2//lib/protocol/http2/stream.rb#156
  def write_headers(priority, headers, flags = T.unsafe(nil)); end

  # A normal request is client request -> server response -> client.
  # A push promise is server request -> client -> server response -> client.
  # The server generates the same set of headers as if the client was sending a request, and sends these to the client. The client can reject the request by resetting the (new) stream. Otherwise, the server will start sending a response as if the client had send the request.
  #
  # source://protocol-http2//lib/protocol/http2/stream.rb#382
  def write_push_promise(stream_id, headers, flags = T.unsafe(nil), **options); end

  class << self
    # source://protocol-http2//lib/protocol/http2/stream.rb#77
    def create(connection, id); end
  end
end

# source://protocol-http2//lib/protocol/http2/error.rb#92
class Protocol::HTTP2::StreamClosed < ::Protocol::HTTP2::StreamError
  # @return [StreamClosed] a new instance of StreamClosed
  #
  # source://protocol-http2//lib/protocol/http2/error.rb#93
  def initialize(message); end
end

# source://protocol-http2//lib/protocol/http2/error.rb#89
class Protocol::HTTP2::StreamError < ::Protocol::HTTP2::ProtocolError; end

# source://protocol-http2//lib/protocol/http2/reset_stream_frame.rb#29
Protocol::HTTP2::TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://protocol-http2//lib/protocol/http2/priority_frame.rb#25
Protocol::HTTP2::VALID_WEIGHT = T.let(T.unsafe(nil), Range)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#25
class Protocol::HTTP2::Window
  # @param capacity [Integer] The initial window size, typically from the settings.
  # @return [Window] a new instance of Window
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#27
  def initialize(capacity = T.unsafe(nil)); end

  # Returns the value of attribute available.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#56
  def available; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#58
  def available?; end

  # Returns the value of attribute capacity.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#42
  def capacity; end

  # When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#45
  def capacity=(value); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#51
  def consume(amount); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#62
  def expand(amount); end

  # The window is completely full?
  #
  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#37
  def full?; end

  # @return [Boolean]
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#76
  def limited?; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#80
  def to_s; end

  # Returns the value of attribute used.
  #
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#41
  def used; end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#72
  def wanted; end
end

# The WINDOW_UPDATE frame is used to implement flow control.
#
# +-+-------------------------------------------------------------+
# |R|              Window Size Increment (31)                     |
# +-+-------------------------------------------------------------+
#
# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#115
class Protocol::HTTP2::WindowUpdateFrame < ::Protocol::HTTP2::Frame
  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#135
  def apply(connection); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#119
  def pack(window_size_increment); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#127
  def read_payload(stream); end

  # source://protocol-http2//lib/protocol/http2/window_update_frame.rb#123
  def unpack; end
end

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#117
Protocol::HTTP2::WindowUpdateFrame::FORMAT = T.let(T.unsafe(nil), String)

# source://protocol-http2//lib/protocol/http2/window_update_frame.rb#116
Protocol::HTTP2::WindowUpdateFrame::TYPE = T.let(T.unsafe(nil), Integer)
