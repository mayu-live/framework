# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-rack` gem.
# Please instead update this file by running `bin/tapioca gem protocol-rack`.

# source://protocol-rack-0.1.6/lib/protocol/rack/version.rb:23
module Protocol; end

# source://protocol-rack-0.1.6/lib/protocol/rack/version.rb:24
module Protocol::Rack; end

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:31
module Protocol::Rack::Adapter
  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter.rb:41
    def make_response(env, response); end

    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter.rb:37
    def new(app); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:32
class Protocol::Rack::Adapter::Generic
  # Initialize the rack adaptor middleware.
  #
  # @raise [ArgumentError]
  # @return [Generic] a new instance of Generic
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:39
  def initialize(app); end

  # Build a rack `env` from the incoming request and apply it to the rack middleware.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:101
  def call(request); end

  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:45
  def logger; end

  # Unwrap raw HTTP headers into the CGI-style expected by Rack middleware.
  #
  # Rack separates multiple headers with the same key, into a single field with multiple lines.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:55
  def unwrap_headers(headers, env); end

  # Process the incoming request into a valid rack `env`.
  #
  # - Set the `env['CONTENT_TYPE']` and `env['CONTENT_LENGTH']` based on the incoming request body.
  # - Set the `env['HTTP_HOST']` header to the request authority.
  # - Set the `env['HTTP_X_FORWARDED_PROTO']` header to the request scheme.
  # - Set `env['REMOTE_ADDR']` to the request remote adress.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:76
  def unwrap_request(request, env); end

  private

  # Generate a suitable response for the given exception.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:122
  def failure_response(exception); end

  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/generic.rb:33
    def wrap(app); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter.rb:34
Protocol::Rack::Adapter::IMPLEMENTATION = Protocol::Rack::Adapter::Rack2

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:31
class Protocol::Rack::Adapter::Rack2 < ::Protocol::Rack::Adapter::Generic
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:44
  def make_environment(request); end

  # Process the rack response headers into into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:95
  def wrap_headers(fields); end

  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:114
    def make_response(env, response); end

    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:40
    def wrap(app); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:38
Protocol::Rack::Adapter::Rack2::RACK_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:37
Protocol::Rack::Adapter::Rack2::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:34
Protocol::Rack::Adapter::Rack2::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:33
Protocol::Rack::Adapter::Rack2::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:35
Protocol::Rack::Adapter::Rack2::RACK_RUN_ONCE = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack2.rb:32
Protocol::Rack::Adapter::Rack2::RACK_VERSION = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack3.rb:30
class Protocol::Rack::Adapter::Rack3 < ::Protocol::Rack::Adapter::Generic
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack3.rb:35
  def make_environment(request); end

  # Process the rack response headers into into a {Protocol::HTTP::Headers} instance, along with any extra `rack.` metadata.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack3.rb:81
  def wrap_headers(fields); end

  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack3.rb:102
    def make_response(env, response); end

    # source://protocol-rack-0.1.6/lib/protocol/rack/adapter/rack3.rb:31
    def wrap(app); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:28
module Protocol::Rack::Body
  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/body.rb:31
    def wrap(status, headers, body, input = T.unsafe(nil)); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/body.rb:29
Protocol::Rack::Body::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Wraps the rack response body.
#
# The `rack` body must respond to `each` and must only yield `String` values. If the body responds to `close`, it will be called after iteration.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:32
class Protocol::Rack::Body::Enumerable < ::Protocol::HTTP::Body::Readable
  # Initialize the output wrapper.
  #
  # @return [Enumerable] a new instance of Enumerable
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:49
  def initialize(body, length); end

  # The rack response body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:57
  def body; end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:97
  def call(stream); end

  # Close the response body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:73
  def close(error = T.unsafe(nil)); end

  # Enumerate the response body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:87
  def each(&block); end

  # Whether the body is empty.
  #
  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:63
  def empty?; end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:113
  def inspect; end

  # The content length of the rack response body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:60
  def length; end

  # Read the next chunk from the response body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:105
  def read; end

  # Whether the body can be read immediately.
  #
  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:68
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:93
  def stream?; end

  class << self
    # Wraps an array into a buffered body.
    #
    # source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:37
    def wrap(body, length = T.unsafe(nil)); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/body/enumerable.rb:33
Protocol::Rack::Body::Enumerable::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# Used for wrapping a generic `rack.input` object into a readable body.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/body/input_wrapper.rb:30
class Protocol::Rack::Body::InputWrapper < ::Protocol::HTTP::Body::Readable
  # @return [InputWrapper] a new instance of InputWrapper
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/input_wrapper.rb:33
  def initialize(io, block_size: T.unsafe(nil)); end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/input_wrapper.rb:40
  def close(error = T.unsafe(nil)); end

  # def join
  # 	@io.read.tap do |buffer|
  # 		buffer.force_encoding(Encoding::BINARY)
  # 	end
  # end
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/input_wrapper.rb:53
  def read; end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/body/input_wrapper.rb:31
Protocol::Rack::Body::InputWrapper::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# Wraps a streaming response body into a compatible Protocol::HTTP body.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:30
class Protocol::Rack::Body::Streaming < ::Protocol::HTTP::Body::Readable
  # @return [Streaming] a new instance of Streaming
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:31
  def initialize(block, input = T.unsafe(nil)); end

  # Returns the value of attribute block.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:36
  def block; end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:48
  def call(stream); end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:38
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:44
  def stream?; end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:52
class Protocol::Rack::Body::Streaming::Output
  # @return [Output] a new instance of Output
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:53
  def initialize(block); end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:61
  def close; end

  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:65
  def empty?; end

  # source://protocol-rack-0.1.6/lib/protocol/rack/body/streaming.rb:57
  def write(chunk); end
end

# CGI keys <https://tools.ietf.org/html/rfc3875#section-4.1>:
#
# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:29
module Protocol::Rack::CGI; end

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:42
Protocol::Rack::CGI::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:41
Protocol::Rack::CGI::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:30
Protocol::Rack::CGI::HTTP_HOST = T.let(T.unsafe(nil), String)

# Header constants:
#
# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:45
Protocol::Rack::CGI::HTTP_X_FORWARDED_PROTO = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:31
Protocol::Rack::CGI::PATH_INFO = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:36
Protocol::Rack::CGI::QUERY_STRING = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:40
Protocol::Rack::CGI::REMOTE_ADDR = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:32
Protocol::Rack::CGI::REQUEST_METHOD = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:33
Protocol::Rack::CGI::REQUEST_PATH = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:34
Protocol::Rack::CGI::REQUEST_URI = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:35
Protocol::Rack::CGI::SCRIPT_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:38
Protocol::Rack::CGI::SERVER_NAME = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:39
Protocol::Rack::CGI::SERVER_PORT = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:37
Protocol::Rack::CGI::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)

# Wraps a streaming input body into the interface required by `rack.input`.
#
# The input stream is an `IO`-like object which contains the raw HTTP POST data. When applicable, its external encoding must be `ASCII-8BIT` and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to `gets`, `each`, `read` and `rewind`.
#
# This implementation is not always rewindable, to avoid buffering the input when handling large uploads. See {Rewindable} for more details.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:33
class Protocol::Rack::Input
  include ::Protocol::HTTP::Body::Stream::Reader

  # Initialize the input wrapper.
  #
  # @return [Input] a new instance of Input
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:36
  def initialize(body); end

  # The input body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:45
  def body; end

  # Close the input and output bodies.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:65
  def close(error = T.unsafe(nil)); end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:93
  def closed?; end

  # Enumerate chunks of the request body.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:54
  def each(&block); end

  # Whether there are any input chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:98
  def empty?; end

  # source://protocol-http-0.23.5/lib/protocol/http/body/stream.rb:95
  def gets(length = T.unsafe(nil)); end

  # Rewind the input stream back to the start.
  #
  # `rewind` must be called without arguments. It rewinds the input stream back to the beginning. It must not raise Errno::ESPIPE: that is, it may not be a pipe or a socket. Therefore, handler developers must buffer the input data into some rewindable object if the underlying input stream is not rewindable.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:79
  def rewind; end

  private

  # source://protocol-rack-0.1.6/lib/protocol/rack/input.rb:104
  def read_next; end
end

# Used for injecting the raw request in the the rack environment.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:26
Protocol::Rack::PROTOCOL_HTTP_REQUEST = T.let(T.unsafe(nil), String)

# Rack environment variables:
#
# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:49
Protocol::Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:51
Protocol::Rack::RACK_INPUT = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:50
Protocol::Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:53
Protocol::Rack::RACK_PROTOCOL = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/constants.rb:52
Protocol::Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:30
class Protocol::Rack::Request < ::Protocol::HTTP::Request
  # @return [Request] a new instance of Request
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:35
  def initialize(env); end

  class << self
    # source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:31
    def [](env); end

    # source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:60
    def headers(env); end

    # source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:52
    def protocol(env); end
  end
end

# source://protocol-rack-0.1.6/lib/protocol/rack/request.rb:50
Protocol::Rack::Request::HTTP_UPGRADE = T.let(T.unsafe(nil), String)

# A wrapper for a `Rack` response.
#
# A Rack response consisting of `[status, headers, body]` includes various rack-specific elements, including:
#
# - A `headers['rack.hijack']` callback which bypasses normal response handling.
# - Potentially invalid content length.
# - Potentially invalid body when processing a `HEAD` request.
# - Newline-separated header values.
# - Other `rack.` specific header key/value pairs.
#
# This wrapper takes those issues into account and adapts the rack response tuple into a {Protocol::HTTP::Response}.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/response.rb:44
class Protocol::Rack::Response < ::Protocol::HTTP::Response
  # Initialize the response wrapper.
  #
  # @return [Response] a new instance of Response
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/response.rb:89
  def initialize(status, headers, body, protocol = T.unsafe(nil)); end

  class << self
    # Wrap a rack response.
    #
    # source://protocol-rack-0.1.6/lib/protocol/rack/response.rb:59
    def wrap(status, headers, meta, body, request = T.unsafe(nil)); end
  end
end

# HTTP hop headers which *should* not be passed through the proxy.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/response.rb:45
Protocol::Rack::Response::HOP_HEADERS = T.let(T.unsafe(nil), Array)

# Content-type driven input buffering, specific to the needs of `rack`.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:30
class Protocol::Rack::Rewindable < ::Protocol::HTTP::Middleware
  # Initialize the rewindable middleware.
  #
  # @return [Rewindable] a new instance of Rewindable
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:42
  def initialize(app); end

  # Wrap the request body in a rewindable buffer if required.
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:70
  def call(request); end

  # source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:63
  def make_environment(request); end

  # Determine whether the request needs a rewindable body.
  #
  # @return [Boolean]
  #
  # source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:49
  def needs_rewind?(request); end
end

# Media types that require buffering.
#
# source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:31
Protocol::Rack::Rewindable::BUFFERED_MEDIA_TYPES = T.let(T.unsafe(nil), Regexp)

# source://protocol-rack-0.1.6/lib/protocol/rack/rewindable.rb:38
Protocol::Rack::Rewindable::POST = T.let(T.unsafe(nil), String)

# source://protocol-rack-0.1.6/lib/protocol/rack/version.rb:25
Protocol::Rack::VERSION = T.let(T.unsafe(nil), String)
