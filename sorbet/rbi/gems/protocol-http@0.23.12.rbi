# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `protocol-http` gem.
# Please instead update this file by running `bin/tapioca gem protocol-http`.

# source://protocol-http//lib/protocol/http/body/readable.rb#25
module Protocol; end

# source://protocol-http//lib/protocol/http/body/readable.rb#26
module Protocol::HTTP; end

# Set a valid accept-encoding header and decode the response.
#
# source://protocol-http//lib/protocol/http/accept_encoding.rb#31
class Protocol::HTTP::AcceptEncoding < ::Protocol::HTTP::Middleware
  # @return [AcceptEncoding] a new instance of AcceptEncoding
  #
  # source://protocol-http//lib/protocol/http/accept_encoding.rb#40
  def initialize(app, wrappers = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/accept_encoding.rb#47
  def call(request); end
end

# source://protocol-http//lib/protocol/http/accept_encoding.rb#32
Protocol::HTTP::AcceptEncoding::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/accept_encoding.rb#33
Protocol::HTTP::AcceptEncoding::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/accept_encoding.rb#35
Protocol::HTTP::AcceptEncoding::DEFAULT_WRAPPERS = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/body/readable.rb#27
module Protocol::HTTP::Body; end

# A body which buffers all it's contents.
#
# source://protocol-http//lib/protocol/http/body/buffered.rb#31
class Protocol::HTTP::Body::Buffered < ::Protocol::HTTP::Body::Readable
  # @return [Buffered] a new instance of Buffered
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#54
  def initialize(chunks = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute chunks.
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#61
  def chunks; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#71
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#63
  def finish; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#96
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#67
  def length; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#80
  def read; end

  # A buffered response is always ready.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/buffered.rb#76
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#92
  def rewind; end

  # source://protocol-http//lib/protocol/http/body/buffered.rb#88
  def write(chunk); end

  class << self
    # source://protocol-http//lib/protocol/http/body/buffered.rb#44
    def for(body); end

    # Wraps an array into a buffered body.
    #
    # @return [Readable, nil] the wrapped body or nil if nil was given.
    #
    # source://protocol-http//lib/protocol/http/body/buffered.rb#32
    def wrap(body); end
  end
end

# Invokes a callback once the body has completed, either successfully or due to an error.
#
# source://protocol-http//lib/protocol/http/body/completable.rb#29
class Protocol::HTTP::Body::Completable < ::Protocol::HTTP::Body::Wrapper
  # @return [Completable] a new instance of Completable
  #
  # source://protocol-http//lib/protocol/http/body/completable.rb#38
  def initialize(body, callback); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#56
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/completable.rb#44
  def finish; end

  class << self
    # source://protocol-http//lib/protocol/http/body/completable.rb#30
    def wrap(message, &block); end
  end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#87
class Protocol::HTTP::Body::Deflate < ::Protocol::HTTP::Body::ZStream
  # source://protocol-http//lib/protocol/http/body/deflate.rb#98
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#92
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/deflate.rb#88
    def for(body, window_size = T.unsafe(nil), level = T.unsafe(nil)); end
  end
end

# source://protocol-http//lib/protocol/http/body/file.rb#29
class Protocol::HTTP::Body::File < ::Protocol::HTTP::Body::Readable
  # @return [File] a new instance of File
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#37
  def initialize(file, range = T.unsafe(nil), size: T.unsafe(nil), block_size: T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/file.rb#52
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#64
  def empty?; end

  # Returns the value of attribute file.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#59
  def file; end

  # source://protocol-http//lib/protocol/http/body/file.rb#102
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/file.rb#92
  def join; end

  # Returns the value of attribute length.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#62
  def length; end

  # Returns the value of attribute offset.
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#61
  def offset; end

  # source://protocol-http//lib/protocol/http/body/file.rb#80
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#68
  def ready?; end

  # source://protocol-http//lib/protocol/http/body/file.rb#72
  def rewind; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/file.rb#76
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/file.rb#33
    def open(path, *arguments, **options); end
  end
end

# source://protocol-http//lib/protocol/http/body/file.rb#30
Protocol::HTTP::Body::File::BLOCK_SIZE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/file.rb#31
Protocol::HTTP::Body::File::MODE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/head.rb#28
class Protocol::HTTP::Body::Head < ::Protocol::HTTP::Body::Readable
  # @return [Head] a new instance of Head
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#37
  def initialize(length); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#41
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/head.rb#49
  def length; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/head.rb#45
  def ready?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/head.rb#29
    def for(body); end
  end
end

# source://protocol-http//lib/protocol/http/body/inflate.rb#30
class Protocol::HTTP::Body::Inflate < ::Protocol::HTTP::Body::ZStream
  # source://protocol-http//lib/protocol/http/body/inflate.rb#39
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/inflate.rb#35
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/inflate.rb#31
    def for(body, encoding = T.unsafe(nil)); end
  end
end

# def finish -> buffer the stream and close it.
# 	def close(error = nil) -> close the stream immediately.
# end
#
# source://protocol-http//lib/protocol/http/body/readable.rb#37
class Protocol::HTTP::Body::Readable
  # Write the body to the given stream.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#70
  def call(stream); end

  # The consumer can call stop to signal that the stream output has terminated.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#39
  def close(error = T.unsafe(nil)); end

  # Enumerate all chunks until finished, then invoke `#close`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#85
  def each; end

  # Will read return any data?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#43
  def empty?; end

  # Read all remaining chunks into a buffered body and close the underlying input.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#79
  def finish; end

  # Read all remaining chunks into a single binary string using `#each`.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#94
  def join; end

  # source://protocol-http//lib/protocol/http/body/readable.rb#54
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#59
  def read; end

  # Whether calling read will block.
  # We prefer pessimistic implementation, and thus default to `false`.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#50
  def ready?; end

  # Should the internal mechanism prefer to use {call}?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/readable.rb#65
  def stream?; end
end

# General operations for interacting with a request or response body.
#
# source://protocol-http//lib/protocol/http/body/reader.rb#27
module Protocol::HTTP::Body::Reader
  # Whether there is a body?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#79
  def body?; end

  # Close the connection as quickly as possible. Discards body. May close the underlying connection if necessary to terminate the stream.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#71
  def close(error = T.unsafe(nil)); end

  # Read chunks from the body.
  #
  # @yield [String] read chunks from the body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#30
  def each(&block); end

  # Gracefully finish reading the body. This will buffer the remainder of the body.
  #
  # @return [Buffered] buffers the entire body.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#50
  def finish; end

  # Reads the entire request/response body.
  #
  # @return [String] the entire body as a string.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#39
  def read; end

  # Write the body of the response to the given file path.
  #
  # source://protocol-http//lib/protocol/http/body/reader.rb#60
  def save(path, mode = T.unsafe(nil), *args); end
end

# The input stream is an IO-like object which contains the raw HTTP POST data. When applicable, its external encoding must be “ASCII-8BIT” and it must be opened in binary mode, for Ruby 1.9 compatibility. The input stream must respond to gets, each, read and rewind.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#29
class Protocol::HTTP::Body::Stream
  include ::Protocol::HTTP::Body::Stream::Reader

  # @raise [ArgumentError]
  # @return [Stream] a new instance of Stream
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#30
  def initialize(input, output = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#158
  def <<(buffer); end

  # Close the input and output bodies.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#177
  def close(error = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#165
  def close_read; end

  # close must never be called on the input stream. huh?
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#171
  def close_write; end

  # Whether the stream has been closed.
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#187
  def closed?; end

  # Whether there are any output chunks remaining?
  #
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#192
  def empty?; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#162
  def flush; end

  # Returns the value of attribute input.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#41
  def input; end

  # Returns the value of attribute output.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#42
  def output; end

  # source://protocol-http//lib/protocol/http/body/stream.rb#145
  def write(buffer); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#154
  def write_nonblock(buffer); end

  private

  # source://protocol-http//lib/protocol/http/body/stream.rb#198
  def read_next; end
end

# This provides a read-only interface for data, which is surprisingly tricky to implement correctly.
#
# source://protocol-http//lib/protocol/http/body/stream.rb#45
module Protocol::HTTP::Body::Stream::Reader
  # read behaves like IO#read. Its signature is read([length, [buffer]]). If given, length must be a non-negative Integer (>= 0) or nil, and buffer must be a String and may not be nil. If length is given and not nil, then this method reads at most length bytes from the input stream. If length is not given or nil, then this method reads all data until EOF. When EOF is reached, this method returns nil if length is given and not nil, or “” if length is not given or is nil. If buffer is given, then the read data will be placed into buffer instead of a newly created String object.
  #
  # @param length [Integer] the amount of data to read
  # @param buffer [String] the buffer which will receive the data
  # @return a buffer containing the data
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#53
  def read(length = T.unsafe(nil), buffer = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/body/stream.rb#116
  def read_nonblock(length, buffer = T.unsafe(nil)); end

  # Read at most `length` bytes from the stream. Will avoid reading from the underlying stream if possible.
  #
  # source://protocol-http//lib/protocol/http/body/stream.rb#95
  def read_partial(length = T.unsafe(nil)); end
end

# Wrapping body instance. Typically you'd override `#read`.
#
# source://protocol-http//lib/protocol/http/body/wrapper.rb#29
class Protocol::HTTP::Body::Wrapper < ::Protocol::HTTP::Body::Readable
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#36
  def initialize(body); end

  # The wrapped body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#41
  def body; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#79
  def call(stream); end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#48
  def close(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#54
  def empty?; end

  # Buffer any remaining body.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#44
  def finish; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#71
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/wrapper.rb#62
  def length; end

  # Read the next available chunk.
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#67
  def read; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#58
  def ready?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/body/wrapper.rb#75
  def stream?; end

  class << self
    # source://protocol-http//lib/protocol/http/body/wrapper.rb#30
    def wrap(message); end
  end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#30
class Protocol::HTTP::Body::ZStream < ::Protocol::HTTP::Body::Wrapper
  # @return [ZStream] a new instance of ZStream
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#51
  def initialize(body, stream); end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#60
  def close(error = T.unsafe(nil)); end

  # Returns the value of attribute input_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#71
  def input_length; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#82
  def inspect; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#66
  def length; end

  # Returns the value of attribute output_length.
  #
  # source://protocol-http//lib/protocol/http/body/deflate.rb#72
  def output_length; end

  # source://protocol-http//lib/protocol/http/body/deflate.rb#74
  def ratio; end

  class << self
    # source://protocol-http//lib/protocol/http/body/deflate.rb#41
    def encoding_name(window_size); end
  end
end

# source://protocol-http//lib/protocol/http/body/deflate.rb#31
Protocol::HTTP::Body::ZStream::DEFAULT_LEVEL = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/deflate.rb#33
Protocol::HTTP::Body::ZStream::DEFLATE = T.let(T.unsafe(nil), Integer)

# source://protocol-http//lib/protocol/http/body/deflate.rb#36
Protocol::HTTP::Body::ZStream::ENCODINGS = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/body/deflate.rb#34
Protocol::HTTP::Body::ZStream::GZIP = T.let(T.unsafe(nil), Integer)

# Represents an individual cookie key-value pair.
#
# source://protocol-http//lib/protocol/http/cookie.rb#28
class Protocol::HTTP::Cookie
  # @return [Cookie] a new instance of Cookie
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#29
  def initialize(name, value, directives); end

  # Returns the value of attribute directives.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#37
  def directives; end

  # source://protocol-http//lib/protocol/http/cookie.rb#39
  def encoded_name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#43
  def encoded_value; end

  # Returns the value of attribute name.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#35
  def name; end

  # source://protocol-http//lib/protocol/http/cookie.rb#47
  def to_s; end

  # Returns the value of attribute value.
  #
  # source://protocol-http//lib/protocol/http/cookie.rb#36
  def value; end

  class << self
    # source://protocol-http//lib/protocol/http/cookie.rb#68
    def parse(string); end

    # source://protocol-http//lib/protocol/http/cookie.rb#81
    def parse_directives(strings); end
  end
end

# A generic, HTTP protocol error.
#
# source://protocol-http//lib/protocol/http/error.rb#26
class Protocol::HTTP::Error < ::StandardError; end

# source://protocol-http//lib/protocol/http/header/split.rb#25
module Protocol::HTTP::Header; end

# Used for basic authorization.
#
# ~~~ ruby
# headers.add('authorization', Authorization.basic("my_username", "my_password"))
# ~~~
#
# source://protocol-http//lib/protocol/http/header/authorization.rb#35
class Protocol::HTTP::Header::Authorization < ::String
  # Splits the header and
  #
  # @return [Tuple(String, String)]
  #
  # source://protocol-http//lib/protocol/http/header/authorization.rb#36
  def credentials; end

  class << self
    # source://protocol-http//lib/protocol/http/header/authorization.rb#40
    def basic(username, password); end
  end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#28
class Protocol::HTTP::Header::CacheControl < ::Protocol::HTTP::Header::Split
  # @return [CacheControl] a new instance of CacheControl
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#39
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#43
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#51
  def dynamic?; end

  # source://protocol-http//lib/protocol/http/header/cache_control.rb#75
  def max_age; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#67
  def no_cache?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#71
  def no_store?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#59
  def private?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#63
  def public?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#47
  def static?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/cache_control.rb#55
  def streaming?; end
end

# source://protocol-http//lib/protocol/http/header/cache_control.rb#36
Protocol::HTTP::Header::CacheControl::DYNAMIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#33
Protocol::HTTP::Header::CacheControl::MAX_AGE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#31
Protocol::HTTP::Header::CacheControl::NO_CACHE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#32
Protocol::HTTP::Header::CacheControl::NO_STORE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#29
Protocol::HTTP::Header::CacheControl::PRIVATE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#30
Protocol::HTTP::Header::CacheControl::PUBLIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#35
Protocol::HTTP::Header::CacheControl::STATIC = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/cache_control.rb#37
Protocol::HTTP::Header::CacheControl::STREAMING = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#28
class Protocol::HTTP::Header::Connection < ::Protocol::HTTP::Header::Split
  # @return [Connection] a new instance of Connection
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#33
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/connection.rb#37
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#45
  def close?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#41
  def keep_alive?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/connection.rb#49
  def upgrade?; end
end

# source://protocol-http//lib/protocol/http/header/connection.rb#30
Protocol::HTTP::Header::Connection::CLOSE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#29
Protocol::HTTP::Header::Connection::KEEP_ALIVE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/header/connection.rb#31
Protocol::HTTP::Header::Connection::UPGRADE = T.let(T.unsafe(nil), String)

# The Cookie HTTP request header contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#30
class Protocol::HTTP::Header::Cookie < ::Protocol::HTTP::Header::Multiple
  # source://protocol-http//lib/protocol/http/header/cookie.rb#31
  def to_h; end
end

# source://protocol-http//lib/protocol/http/header/etag.rb#26
class Protocol::HTTP::Header::ETag < ::String
  # source://protocol-http//lib/protocol/http/header/etag.rb#27
  def <<(value); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etag.rb#31
  def weak?; end
end

# This implementation is not strictly correct according to the RFC-specified format.
#
# source://protocol-http//lib/protocol/http/header/etags.rb#29
class Protocol::HTTP::Header::ETags < ::Protocol::HTTP::Header::Split
  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#34
  def match?(etag); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/header/etags.rb#30
  def wildcard?; end
end

# Header value which is split by newline charaters (e.g. cookies).
#
# source://protocol-http//lib/protocol/http/header/multiple.rb#27
class Protocol::HTTP::Header::Multiple < ::Array
  # @return [Multiple] a new instance of Multiple
  #
  # source://protocol-http//lib/protocol/http/header/multiple.rb#28
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/multiple.rb#34
  def to_s; end
end

# The Set-Cookie HTTP response header sends cookies from the server to the user agent.
#
# source://protocol-http//lib/protocol/http/header/cookie.rb#41
class Protocol::HTTP::Header::SetCookie < ::Protocol::HTTP::Header::Cookie; end

# Header value which is split by commas.
#
# source://protocol-http//lib/protocol/http/header/split.rb#27
class Protocol::HTTP::Header::Split < ::Array
  # @return [Split] a new instance of Split
  #
  # source://protocol-http//lib/protocol/http/header/split.rb#30
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#34
  def <<(value); end

  # source://protocol-http//lib/protocol/http/header/split.rb#38
  def to_s; end
end

# source://protocol-http//lib/protocol/http/header/split.rb#28
Protocol::HTTP::Header::Split::COMMA = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/header/vary.rb#28
class Protocol::HTTP::Header::Vary < ::Protocol::HTTP::Header::Split
  # @return [Vary] a new instance of Vary
  #
  # source://protocol-http//lib/protocol/http/header/vary.rb#29
  def initialize(value); end

  # source://protocol-http//lib/protocol/http/header/vary.rb#33
  def <<(value); end
end

# Headers are an array of key-value pairs. Some header keys represent multiple values.
#
# source://protocol-http//lib/protocol/http/headers.rb#36
class Protocol::HTTP::Headers
  # @return [Headers] a new instance of Headers
  #
  # source://protocol-http//lib/protocol/http/headers.rb#66
  def initialize(fields = T.unsafe(nil), indexed = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/headers.rb#316
  def ==(other); end

  # source://protocol-http//lib/protocol/http/headers.rb#299
  def [](key); end

  # Append the value to the given key. Some values can be appended multiple times, others can only be set once.
  #
  # @param key [String] The header key.
  # @param value The header value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#212
  def []=(key, value); end

  # Add the specified header key value pair.
  #
  # @param key [String] the header key.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#184
  def add(key, value); end

  # source://protocol-http//lib/protocol/http/headers.rb#81
  def clear; end

  # Delete all headers with the given key, and return the merged value.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#262
  def delete(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#152
  def each(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#148
  def empty?; end

  # source://protocol-http//lib/protocol/http/headers.rb#166
  def extract(keys); end

  # An array of `[key, value]` pairs.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#102
  def fields; end

  # source://protocol-http//lib/protocol/http/headers.rb#97
  def flatten; end

  # Flatten trailer into the headers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#88
  def flatten!; end

  # source://protocol-http//lib/protocol/http/headers.rb#136
  def freeze; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#156
  def include?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#312
  def inspect; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#156
  def key?(key); end

  # source://protocol-http//lib/protocol/http/headers.rb#162
  def keys; end

  # source://protocol-http//lib/protocol/http/headers.rb#205
  def merge(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#197
  def merge!(headers); end

  # Set the specified header key to the specified value, replacing any existing header keys with the same name.
  #
  # @param key [String] the header key to replace.
  # @param value [String] the header value to assign.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#191
  def set(key, value); end

  # A hash table of `{key, policy[key].map(values)}`
  #
  # source://protocol-http//lib/protocol/http/headers.rb#304
  def to_h; end

  # Enumerate all headers in the trailer, if there are any.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#128
  def trailer(&block); end

  # Record the current headers, and prepare to add trailers.
  #
  # This method is typically used after headers are sent to capture any
  # additional headers which should then be sent as trailers.
  #
  # A sender that intends to generate one or more trailer fields in a
  # message should generate a trailer header field in the header section of
  # that message to indicate which fields might be present in the trailers.
  #
  # source://protocol-http//lib/protocol/http/headers.rb#121
  def trailer!(&block); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/headers.rb#105
  def trailer?; end

  protected

  # source://protocol-http//lib/protocol/http/headers.rb#286
  def merge_into(hash, key, value); end

  private

  # source://protocol-http//lib/protocol/http/headers.rb#74
  def initialize_dup(other); end

  class << self
    # Construct an instance from a headers Array or Hash. No-op if already an instance of `Headers`. If the underlying array is frozen, it will be duped.
    #
    # @return [Headers] an instance of headers.
    #
    # source://protocol-http//lib/protocol/http/headers.rb#44
    def [](headers); end
  end
end

# Used for merging objects into a sequential list of headers. Normalizes header keys and values.
#
# source://protocol-http//lib/protocol/http/headers.rb#328
class Protocol::HTTP::Headers::Merged
  include ::Enumerable

  # @return [Merged] a new instance of Merged
  #
  # source://protocol-http//lib/protocol/http/headers.rb#331
  def initialize(*all); end

  # source://protocol-http//lib/protocol/http/headers.rb#339
  def <<(headers); end

  # source://protocol-http//lib/protocol/http/headers.rb#335
  def clear; end

  # source://protocol-http//lib/protocol/http/headers.rb#346
  def each(&block); end
end

# source://protocol-http//lib/protocol/http/headers.rb#38
Protocol::HTTP::Headers::Multiple = Protocol::HTTP::Header::Multiple

# source://protocol-http//lib/protocol/http/headers.rb#220
Protocol::HTTP::Headers::POLICY = T.let(T.unsafe(nil), Hash)

# source://protocol-http//lib/protocol/http/headers.rb#37
Protocol::HTTP::Headers::Split = Protocol::HTTP::Header::Split

# source://protocol-http//lib/protocol/http/headers.rb#40
Protocol::HTTP::Headers::TRAILER = T.let(T.unsafe(nil), String)

# All supported HTTP methods
#
# source://protocol-http//lib/protocol/http/methods.rb#26
class Protocol::HTTP::Methods
  # source://protocol-http//lib/protocol/http/methods.rb#54
  def connect(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def delete(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def get(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def head(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def link(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def options(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def patch(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def post(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def put(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def trace(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://protocol-http//lib/protocol/http/methods.rb#54
  def unlink(location, headers = T.unsafe(nil), body = T.unsafe(nil)); end

  class << self
    # source://protocol-http//lib/protocol/http/methods.rb#46
    def each; end

    # @return [Boolean]
    #
    # source://protocol-http//lib/protocol/http/methods.rb#39
    def valid?(name); end
  end
end

# source://protocol-http//lib/protocol/http/methods.rb#37
Protocol::HTTP::Methods::CONNECT = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#31
Protocol::HTTP::Methods::DELETE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#27
Protocol::HTTP::Methods::GET = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#32
Protocol::HTTP::Methods::HEAD = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#34
Protocol::HTTP::Methods::LINK = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#33
Protocol::HTTP::Methods::OPTIONS = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#30
Protocol::HTTP::Methods::PATCH = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#28
Protocol::HTTP::Methods::POST = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#29
Protocol::HTTP::Methods::PUT = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#36
Protocol::HTTP::Methods::TRACE = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/methods.rb#35
Protocol::HTTP::Methods::UNLINK = T.let(T.unsafe(nil), String)

# source://protocol-http//lib/protocol/http/middleware.rb#31
class Protocol::HTTP::Middleware < ::Protocol::HTTP::Methods
  # @return [Middleware] a new instance of Middleware
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#39
  def initialize(delegate); end

  # source://protocol-http//lib/protocol/http/middleware.rb#49
  def call(request); end

  # source://protocol-http//lib/protocol/http/middleware.rb#45
  def close; end

  # Returns the value of attribute delegate.
  #
  # source://protocol-http//lib/protocol/http/middleware.rb#43
  def delegate; end

  class << self
    # Convert a block to a middleware delegate.
    #
    # source://protocol-http//lib/protocol/http/middleware.rb#32
    def for(&block); end
  end
end

# source://protocol-http//lib/protocol/http/middleware.rb#71
module Protocol::HTTP::Middleware::HelloWorld
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#75
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#72
    def close; end
  end
end

# source://protocol-http//lib/protocol/http/middleware.rb#62
module Protocol::HTTP::Middleware::NotFound
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#66
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#63
    def close; end
  end
end

# source://protocol-http//lib/protocol/http/middleware.rb#53
module Protocol::HTTP::Middleware::Okay
  class << self
    # source://protocol-http//lib/protocol/http/middleware.rb#57
    def call(request); end

    # source://protocol-http//lib/protocol/http/middleware.rb#54
    def close; end
  end
end

# source://protocol-http//lib/protocol/http/request.rb#31
class Protocol::HTTP::Request
  include ::Protocol::HTTP::Body::Reader

  # @return [Request] a new instance of Request
  #
  # source://protocol-http//lib/protocol/http/request.rb#34
  def initialize(scheme = T.unsafe(nil), authority = T.unsafe(nil), method = T.unsafe(nil), path = T.unsafe(nil), version = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#49
  def authority; end

  # The request authority, usually a hostname and port number.
  #
  # source://protocol-http//lib/protocol/http/request.rb#49
  def authority=(_arg0); end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def body; end

  # The request body, an instance of Protocol::HTTP::Body::Readable or similar.
  #
  # source://protocol-http//lib/protocol/http/request.rb#64
  def body=(_arg0); end

  # Send the request to the given connection.
  #
  # source://protocol-http//lib/protocol/http/request.rb#70
  def call(connection); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#78
  def connect?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#74
  def head?; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def headers; end

  # The request headers, contains metadata associated with the request such as the user agent, accept (content type), accept-language, etc.
  #
  # source://protocol-http//lib/protocol/http/request.rb#61
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/request.rb#89
  def idempotent?; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def method; end

  # The request method, usually one of "GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT" or "OPTIONS".
  #
  # source://protocol-http//lib/protocol/http/request.rb#52
  def method=(_arg0); end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def path; end

  # The request path, usually a path and query string.
  #
  # source://protocol-http//lib/protocol/http/request.rb#55
  def path=(_arg0); end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def protocol; end

  # The request protocol, usually empty, but occasionally "websocket" or "webtransport", can be either single value `String` or multi-value `Array` of `String` instances. In HTTP/1, it is used to request a connection upgrade, and in HTTP/2 it is used to indicate a specfic protocol for the stream.
  #
  # source://protocol-http//lib/protocol/http/request.rb#67
  def protocol=(_arg0); end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#46
  def scheme; end

  # The request scheme, usually one of "http" or "https".
  #
  # source://protocol-http//lib/protocol/http/request.rb#46
  def scheme=(_arg0); end

  # source://protocol-http//lib/protocol/http/request.rb#93
  def to_s; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def version; end

  # The request version, usually "http/1.0", "http/1.1", "h2", or "h3".
  #
  # source://protocol-http//lib/protocol/http/request.rb#58
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/request.rb#82
    def [](method, path, headers, body); end
  end
end

# source://protocol-http//lib/protocol/http/response.rb#28
class Protocol::HTTP::Response
  include ::Protocol::HTTP::Body::Reader

  # @return [Response] a new instance of Response
  #
  # source://protocol-http//lib/protocol/http/response.rb#31
  def initialize(version = T.unsafe(nil), status = T.unsafe(nil), headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#77
  def bad_request?; end

  # Returns the value of attribute body.
  #
  # source://protocol-http//lib/protocol/http/response.rb#42
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#42
  def body=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#49
  def continue?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#73
  def failure?; end

  # Returns the value of attribute headers.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#41
  def headers=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#45
  def hijack?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#65
  def not_modified?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#57
  def partial?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#69
  def preserve_method?; end

  # Returns the value of attribute protocol.
  #
  # source://protocol-http//lib/protocol/http/response.rb#43
  def protocol; end

  # Sets the attribute protocol
  #
  # @param value the value to set the attribute protocol to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#43
  def protocol=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#61
  def redirection?; end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#81
  def server_failure?; end

  # Returns the value of attribute status.
  #
  # source://protocol-http//lib/protocol/http/response.rb#40
  def status; end

  # Sets the attribute status
  #
  # @param value the value to set the attribute status to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#40
  def status=(_arg0); end

  # @return [Boolean]
  #
  # source://protocol-http//lib/protocol/http/response.rb#53
  def success?; end

  # source://protocol-http//lib/protocol/http/response.rb#100
  def to_ary; end

  # source://protocol-http//lib/protocol/http/response.rb#96
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://protocol-http//lib/protocol/http/response.rb#39
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://protocol-http//lib/protocol/http/response.rb#39
  def version=(_arg0); end

  class << self
    # source://protocol-http//lib/protocol/http/response.rb#85
    def [](status, headers = T.unsafe(nil), body = T.unsafe(nil), protocol = T.unsafe(nil)); end

    # source://protocol-http//lib/protocol/http/response.rb#92
    def for_exception(exception); end
  end
end

# source://protocol-http//lib/protocol/http/url.rb#25
module Protocol::HTTP::URL
  class << self
    # source://protocol-http//lib/protocol/http/url.rb#87
    def assign(keys, value, parent); end

    # TODO use native C extension from `Trenni::Reference`.
    #
    # source://protocol-http//lib/protocol/http/url.rb#108
    def decode(string, maximum = T.unsafe(nil), symbolize_keys: T.unsafe(nil)); end

    # Encodes a hash or array into a query string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#52
    def encode(value, prefix = T.unsafe(nil)); end

    # Escapes a string using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#27
    def escape(string, encoding = T.unsafe(nil)); end

    # Escapes non-path characters using percent encoding.
    #
    # source://protocol-http//lib/protocol/http/url.rb#44
    def escape_path(path); end

    # Scan a string for URL-encoded key/value pairs.
    #
    # source://protocol-http//lib/protocol/http/url.rb#75
    def scan(string); end

    # source://protocol-http//lib/protocol/http/url.rb#83
    def split(name); end

    # Unescapes a percent encoded string.
    #
    # source://protocol-http//lib/protocol/http/url.rb#34
    def unescape(string, encoding = T.unsafe(nil)); end
  end
end

# According to https://tools.ietf.org/html/rfc3986#section-3.3, we escape non-pchar.
#
# source://protocol-http//lib/protocol/http/url.rb#41
Protocol::HTTP::URL::NON_PCHAR = T.let(T.unsafe(nil), Regexp)

# source://protocol-http//lib/protocol/http/version.rb#25
Protocol::HTTP::VERSION = T.let(T.unsafe(nil), String)
