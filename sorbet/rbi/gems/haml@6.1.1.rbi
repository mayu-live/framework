# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `haml` gem.
# Please instead update this file by running `bin/tapioca gem haml`.

# There are only helpers that depend on ActionView internals.
#
# source://haml//lib/haml/error.rb#2
module Haml; end

# source://haml//lib/haml/ambles.rb#3
class Haml::Ambles < ::Temple::Filter
  # @return [Ambles] a new instance of Ambles
  #
  # source://haml//lib/haml/ambles.rb#6
  def initialize(*_arg0); end

  # source://haml//lib/haml/ambles.rb#12
  def call(ast); end
end

# source://haml//lib/haml/attribute_builder.rb#4
module Haml::AttributeBuilder
  class << self
    def build(*_arg0); end
    def build_aria(*_arg0); end
    def build_class(*_arg0); end
    def build_data(*_arg0); end
    def build_id(*_arg0); end
  end
end

# source://haml//lib/haml/attribute_builder.rb#5
Haml::AttributeBuilder::BOOLEAN_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# source://haml//lib/haml/attribute_compiler.rb#7
class Haml::AttributeCompiler
  # @return [AttributeCompiler] a new instance of AttributeCompiler
  #
  # source://haml//lib/haml/attribute_compiler.rb#8
  def initialize(identity, options); end

  # source://haml//lib/haml/attribute_compiler.rb#15
  def compile(node); end

  private

  # source://haml//lib/haml/attribute_compiler.rb#118
  def attribute_builder(type, values); end

  # source://haml//lib/haml/attribute_compiler.rb#93
  def compile_boolean!(temple, key, values); end

  # source://haml//lib/haml/attribute_compiler.rb#73
  def compile_class!(temple, key, values); end

  # source://haml//lib/haml/attribute_compiler.rb#114
  def compile_common!(temple, key, values); end

  # source://haml//lib/haml/attribute_compiler.rb#82
  def compile_data!(temple, key, values); end

  # source://haml//lib/haml/attribute_compiler.rb#64
  def compile_id!(temple, key, values); end

  # source://haml//lib/haml/attribute_compiler.rb#123
  def literal_for(value); end

  # source://haml//lib/haml/attribute_compiler.rb#30
  def runtime_compile(node); end

  # source://haml//lib/haml/attribute_compiler.rb#41
  def static_compile(static_hash, dynamic_hashes); end
end

# source://haml//lib/haml/attribute_parser.rb#5
class Haml::AttributeParser
  # source://haml//lib/haml/attribute_parser.rb#19
  def parse(text); end

  private

  # @raise [ParseSkip]
  #
  # source://haml//lib/haml/attribute_parser.rb#67
  def assert_type!(token, type); end

  # @yield [attr_tokens]
  #
  # source://haml//lib/haml/attribute_parser.rb#78
  def each_attr(tokens); end

  # source://haml//lib/haml/attribute_parser.rb#42
  def parse_key!(tokens); end

  # source://haml//lib/haml/attribute_parser.rb#71
  def skip_until_hash_rocket!(tokens); end

  # source://haml//lib/haml/attribute_parser.rb#36
  def wrap_bracket(text); end

  class << self
    # @return [TrueClass, FalseClass] - return true if AttributeParser.parse can be used.
    #
    # source://haml//lib/haml/attribute_parser.rb#10
    def available?; end

    # source://haml//lib/haml/attribute_parser.rb#15
    def parse(text); end
  end
end

# source://haml//lib/haml/attribute_parser.rb#6
class Haml::AttributeParser::ParseSkip < ::StandardError; end

# source://haml//lib/haml/compiler/children_compiler.rb#5
class Haml::Compiler
  # @return [Compiler] a new instance of Compiler
  #
  # source://haml//lib/haml/compiler.rb#13
  def initialize(options = T.unsafe(nil)); end

  # source://haml//lib/haml/compiler.rb#24
  def call(ast); end

  private

  # source://haml//lib/haml/compiler.rb#33
  def compile(node); end

  # source://haml//lib/haml/compiler.rb#58
  def compile_children(node); end

  # source://haml//lib/haml/compiler.rb#62
  def compile_comment(node); end

  # source://haml//lib/haml/compiler.rb#66
  def compile_doctype(node); end

  # source://haml//lib/haml/compiler.rb#70
  def compile_filter(node); end

  # source://haml//lib/haml/compiler.rb#74
  def compile_plain(node); end

  # source://haml//lib/haml/compiler.rb#78
  def compile_script(node); end

  # source://haml//lib/haml/compiler.rb#82
  def compile_silent_script(node); end

  # source://haml//lib/haml/compiler.rb#86
  def compile_tag(node); end

  # source://haml//lib/haml/compiler.rb#90
  def runtime_error(error); end
end

# source://haml//lib/haml/compiler/children_compiler.rb#6
class Haml::Compiler::ChildrenCompiler
  # @return [ChildrenCompiler] a new instance of ChildrenCompiler
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#7
  def initialize; end

  # source://haml//lib/haml/compiler/children_compiler.rb#12
  def compile(node, &block); end

  private

  # source://haml//lib/haml/compiler/children_compiler.rb#125
  def find_else_index(temple); end

  # source://haml//lib/haml/compiler/children_compiler.rb#29
  def insert_newlines!(temple, node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#137
  def insert_whitespace?(node); end

  # source://haml//lib/haml/compiler/children_compiler.rb#37
  def moving_lineno(node, &block); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#65
  def nuke_inner_whitespace?(node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#87
  def nuke_outer_whitespace?(node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#76
  def nuke_prev_whitespace?(node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/children_compiler.rb#60
  def prepend_whitespace?(node); end

  # source://haml//lib/haml/compiler/children_compiler.rb#92
  def rstrip_whitespace!(temple); end
end

# source://haml//lib/haml/compiler/comment_compiler.rb#4
class Haml::Compiler::CommentCompiler
  # source://haml//lib/haml/compiler/comment_compiler.rb#5
  def compile(node, &block); end

  private

  # source://haml//lib/haml/compiler/comment_compiler.rb#23
  def compile_conditional_comment(node, &block); end

  # source://haml//lib/haml/compiler/comment_compiler.rb#15
  def compile_html_comment(node, &block); end

  # source://haml//lib/haml/compiler/comment_compiler.rb#38
  def compile_text(node); end
end

# source://haml//lib/haml/compiler/doctype_compiler.rb#4
class Haml::Compiler::DoctypeCompiler
  # @return [DoctypeCompiler] a new instance of DoctypeCompiler
  #
  # source://haml//lib/haml/compiler/doctype_compiler.rb#5
  def initialize(options = T.unsafe(nil)); end

  # source://haml//lib/haml/compiler/doctype_compiler.rb#9
  def compile(node); end

  private

  # source://haml//lib/haml/compiler/doctype_compiler.rb#22
  def html_doctype(node); end

  # source://haml//lib/haml/compiler/doctype_compiler.rb#36
  def xml_doctype; end
end

# source://haml//lib/haml/compiler/script_compiler.rb#8
class Haml::Compiler::ScriptCompiler
  # @return [ScriptCompiler] a new instance of ScriptCompiler
  #
  # source://haml//lib/haml/compiler/script_compiler.rb#18
  def initialize(identity, options); end

  # source://haml//lib/haml/compiler/script_compiler.rb#23
  def compile(node, &block); end

  private

  # String-interpolated plain text must be compiled with this method
  # because we have to escape only interpolated values.
  #
  # source://haml//lib/haml/compiler/script_compiler.rb#45
  def compile_interpolated_plain(node); end

  # source://haml//lib/haml/compiler/script_compiler.rb#82
  def compile_script_assign(var, node, &block); end

  # source://haml//lib/haml/compiler/script_compiler.rb#98
  def compile_script_result(result, node); end

  # :dynamic is optimized in other filter: StringSplitter
  #
  # source://haml//lib/haml/compiler/script_compiler.rb#59
  def delegate_optimization(node); end

  # source://haml//lib/haml/compiler/script_compiler.rb#76
  def dynamic_compile(node, &block); end

  # source://haml//lib/haml/compiler/script_compiler.rb#109
  def escape_html(temple); end

  # source://haml//lib/haml/compiler/script_compiler.rb#105
  def find_and_preserve(code); end

  # source://haml//lib/haml/compiler/script_compiler.rb#66
  def static_compile(node); end

  class << self
    # source://haml//lib/haml/compiler/script_compiler.rb#9
    def find_and_preserve(input, tags); end
  end
end

# source://haml//lib/haml/compiler/silent_script_compiler.rb#4
class Haml::Compiler::SilentScriptCompiler
  # source://haml//lib/haml/compiler/silent_script_compiler.rb#5
  def compile(node, &block); end

  private

  # source://haml//lib/haml/compiler/silent_script_compiler.rb#15
  def compile_with_children(node, &block); end
end

# source://haml//lib/haml/compiler/tag_compiler.rb#8
class Haml::Compiler::TagCompiler
  # @return [TagCompiler] a new instance of TagCompiler
  #
  # source://haml//lib/haml/compiler/tag_compiler.rb#9
  def initialize(identity, options); end

  # source://haml//lib/haml/compiler/tag_compiler.rb#15
  def compile(node, &block); end

  private

  # source://haml//lib/haml/compiler/tag_compiler.rb#23
  def compile_contents(node, &block); end

  # We should handle interpolation here to escape only interpolated values.
  #
  # source://haml//lib/haml/compiler/tag_compiler.rb#57
  def compile_interpolated_plain(node); end

  # :dynamic is optimized in other filters: StringSplitter or StaticAnalyzer
  #
  # source://haml//lib/haml/compiler/tag_compiler.rb#49
  def delegate_optimization(node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/compiler/tag_compiler.rb#70
  def self_closing?(node); end
end

# Compile [:multi, [:static, 'foo'], [:dynamic, 'bar']] to [:dynamic, '"foo#{bar}"']
#
# source://haml//lib/haml/dynamic_merger.rb#4
class Haml::DynamicMerger < ::Temple::Filter
  # source://haml//lib/haml/dynamic_merger.rb#5
  def on_multi(*exps); end

  private

  # source://haml//lib/haml/dynamic_merger.rb#55
  def count_newline(exps); end

  # source://haml//lib/haml/dynamic_merger.rb#33
  def merge_dynamic(exps); end
end

# source://haml//lib/haml/engine.rb#15
class Haml::Engine < ::Temple::Engine; end

# source://haml//lib/haml/error.rb#3
class Haml::Error < ::StandardError
  # @param message [String] The error message
  # @param line [Fixnum] See \{#line}
  # @return [Error] a new instance of Error
  #
  # source://haml//lib/haml/error.rb#49
  def initialize(message = T.unsafe(nil), line = T.unsafe(nil)); end

  # The line of the template on which the error occurred.
  #
  # @return [Fixnum]
  #
  # source://haml//lib/haml/error.rb#45
  def line; end

  class << self
    # source://haml//lib/haml/error.rb#37
    def message(key, *args); end
  end
end

# source://haml//lib/haml/error.rb#4
Haml::Error::MESSAGES = T.let(T.unsafe(nil), Hash)

# source://haml//lib/haml/escape.rb#5
class Haml::Escape < ::Temple::Filters::Escapable
  # @return [Escape] a new instance of Escape
  #
  # source://haml//lib/haml/escape.rb#6
  def initialize(opts = T.unsafe(nil)); end
end

# Unlike Haml::Escape, this calls to_s when not escaped.
#
# source://haml//lib/haml/escape_any.rb#14
class Haml::EscapeAny < ::Haml::Escape
  # source://haml//lib/haml/escape_any.rb#17
  def on_dynamic(value); end

  # source://temple/0.9.1/lib/temple/filters/escapable.rb#23
  def on_escapeany(flag, exp); end
end

# This module allows Temple::Filter to dispatch :fescape on `#compile`.
#
# source://haml//lib/haml/escape_any.rb#6
module Haml::EscapeanyDispathcer
  # source://haml//lib/haml/escape_any.rb#7
  def on_escapeany(flag, exp); end
end

# This module allows Temple::Filter to dispatch :fescape on `#compile`.
#
# source://haml//lib/haml/force_escape.rb#6
module Haml::FescapeDispathcer
  # source://haml//lib/haml/force_escape.rb#7
  def on_fescape(flag, exp); end
end

# An invalid filter name was used.
#
# source://haml//lib/haml/error.rb#62
class Haml::FilterNotFound < ::Haml::Error; end

# source://haml//lib/haml/filters/base.rb#5
class Haml::Filters
  # @return [Filters] a new instance of Filters
  #
  # source://haml//lib/haml/filters.rb#55
  def initialize(options = T.unsafe(nil)); end

  # source://haml//lib/haml/filters.rb#60
  def compile(node); end

  private

  # @raise [FilterNotFound]
  #
  # source://haml//lib/haml/filters.rb#67
  def find_compiler(node); end

  class << self
    # Returns the value of attribute registered.
    #
    # source://haml//lib/haml/filters.rb#24
    def registered; end

    # source://haml//lib/haml/filters.rb#26
    def remove_filter(name); end

    private

    # source://haml//lib/haml/filters.rb#35
    def register(name, compiler); end
  end
end

# source://haml//lib/haml/filters/base.rb#6
class Haml::Filters::Base
  # @return [Base] a new instance of Base
  #
  # source://haml//lib/haml/filters/base.rb#7
  def initialize(options = T.unsafe(nil)); end
end

# source://haml//lib/haml/filters/cdata.rb#4
class Haml::Filters::Cdata < ::Haml::Filters::TextBase
  # source://haml//lib/haml/filters/cdata.rb#5
  def compile(node); end

  private

  # source://haml//lib/haml/filters/cdata.rb#11
  def compile_cdata(node); end
end

# source://haml//lib/haml/filters/coffee.rb#4
class Haml::Filters::Coffee < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/coffee.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/coffee.rb#15
Haml::Filters::CoffeeScript = Haml::Filters::Coffee

# source://haml//lib/haml/filters/css.rb#4
class Haml::Filters::Css < ::Haml::Filters::TextBase
  # source://haml//lib/haml/filters/css.rb#5
  def compile(node); end

  private

  # source://haml//lib/haml/filters/css.rb#16
  def compile_html(node); end

  # source://haml//lib/haml/filters/css.rb#24
  def compile_xhtml(node); end
end

# source://haml//lib/haml/filters/erb.rb#4
class Haml::Filters::Erb < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/erb.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/escaped.rb#4
class Haml::Filters::Escaped < ::Haml::Filters::Base
  # source://haml//lib/haml/filters/escaped.rb#5
  def compile(node); end

  private

  # source://haml//lib/haml/filters/escaped.rb#13
  def compile_text(text); end
end

# source://haml//lib/haml/filters/javascript.rb#4
class Haml::Filters::Javascript < ::Haml::Filters::TextBase
  # source://haml//lib/haml/filters/javascript.rb#5
  def compile(node); end

  private

  # source://haml//lib/haml/filters/javascript.rb#16
  def compile_html(node); end

  # source://haml//lib/haml/filters/javascript.rb#24
  def compile_xhtml(node); end
end

# source://haml//lib/haml/filters/less.rb#9
class Haml::Filters::Less < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/less.rb#10
  def compile(node); end
end

# source://haml//lib/haml/filters/markdown.rb#4
class Haml::Filters::Markdown < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/markdown.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/plain.rb#6
class Haml::Filters::Plain < ::Haml::Filters::Base
  # source://haml//lib/haml/filters/plain.rb#7
  def compile(node); end

  private

  # source://haml//lib/haml/filters/plain.rb#15
  def compile_plain(text); end
end

# source://haml//lib/haml/filters/preserve.rb#4
class Haml::Filters::Preserve < ::Haml::Filters::Base
  # source://haml//lib/haml/filters/preserve.rb#5
  def compile(node); end

  private

  # source://haml//lib/haml/filters/preserve.rb#13
  def compile_text(text); end
end

# source://haml//lib/haml/filters/ruby.rb#4
class Haml::Filters::Ruby < ::Haml::Filters::Base
  # source://haml//lib/haml/filters/ruby.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/sass.rb#4
class Haml::Filters::Sass < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/sass.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/scss.rb#4
class Haml::Filters::Scss < ::Haml::Filters::TiltBase
  # source://haml//lib/haml/filters/scss.rb#5
  def compile(node); end
end

# source://haml//lib/haml/filters/text_base.rb#4
class Haml::Filters::TextBase < ::Haml::Filters::Base
  # source://haml//lib/haml/filters/text_base.rb#5
  def compile_text!(temple, node, prefix); end
end

# source://haml//lib/haml/filters/tilt_base.rb#6
class Haml::Filters::TiltBase < ::Haml::Filters::Base
  # @return [Boolean]
  #
  # source://haml//lib/haml/filters/tilt_base.rb#17
  def explicit_require?(needed_registration); end

  private

  # source://haml//lib/haml/filters/tilt_base.rb#30
  def compile_with_tilt(node, name, indent_width: T.unsafe(nil)); end

  # source://haml//lib/haml/filters/tilt_base.rb#46
  def dynamic_compile(node, name, indent_width: T.unsafe(nil)); end

  # TODO: support interpolation
  #
  # source://haml//lib/haml/filters/tilt_base.rb#25
  def precompiled_with_tilt(node, name); end

  # source://haml//lib/haml/filters/tilt_base.rb#38
  def static_compile(node, name, indent_width: T.unsafe(nil)); end

  class << self
    # source://haml//lib/haml/filters/tilt_base.rb#7
    def render(name, source, indent_width: T.unsafe(nil)); end
  end
end

# Unlike Haml::Escape, this escapes value even if it's html_safe.
#
# source://haml//lib/haml/force_escape.rb#14
class Haml::ForceEscape < ::Haml::Escape
  # @return [ForceEscape] a new instance of ForceEscape
  #
  # source://haml//lib/haml/force_escape.rb#15
  def initialize(opts = T.unsafe(nil)); end

  # ForceEscape doesn't touch :escape expression.
  # This method is not used if it's inserted after Haml::Escape.
  #
  # source://haml//lib/haml/force_escape.rb#25
  def on_escape(flag, exp); end

  # source://temple/0.9.1/lib/temple/filters/escapable.rb#23
  def on_fescape(flag, exp); end
end

# source://haml//lib/haml/html.rb#3
class Haml::HTML < ::Temple::HTML::Fast
  # @return [HTML] a new instance of HTML
  #
  # source://haml//lib/haml/html.rb#6
  def initialize(opts = T.unsafe(nil)); end

  # This dispatcher supports Haml's "revealed" conditional comment.
  #
  # source://haml//lib/haml/html.rb#15
  def on_html_condcomment(condition, content, revealed = T.unsafe(nil)); end
end

# source://haml//lib/haml/html.rb#4
Haml::HTML::DEPRECATED_FORMATS = T.let(T.unsafe(nil), Array)

# source://haml//lib/haml/helpers.rb#3
module Haml::Helpers
  # source://haml//lib/haml/helpers.rb#11
  def preserve(input); end

  class << self
    # source://haml//lib/haml/helpers.rb#4
    def preserve(input); end
  end
end

# source://haml//lib/haml/identity.rb#3
class Haml::Identity
  # @return [Identity] a new instance of Identity
  #
  # source://haml//lib/haml/identity.rb#4
  def initialize; end

  # source://haml//lib/haml/identity.rb#8
  def generate; end
end

# InternalError means that you hit a bug of Haml itself.
#
# source://haml//lib/haml/error.rb#65
class Haml::InternalError < ::Haml::Error; end

# source://haml//lib/haml/object_ref.rb#3
module Haml::ObjectRef
  class << self
    # source://haml//lib/haml/object_ref.rb#5
    def parse(args); end

    private

    # Haml::Buffer.underscore
    #
    # source://haml//lib/haml/object_ref.rb#24
    def underscore(camel_cased_word); end
  end
end

# source://haml//lib/haml/parser.rb#9
class Haml::Parser
  include ::Haml::Util

  # @return [Parser] a new instance of Parser
  #
  # source://haml//lib/haml/parser.rb#99
  def initialize(options); end

  # source://haml//lib/haml/parser.rb#112
  def call(template); end

  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#169
  def compute_tabs(line); end

  # Returns the value of attribute root.
  #
  # source://haml//lib/haml/parser.rb#12
  def root; end

  private

  # source://haml//lib/haml/parser.rb#844
  def balance(*args); end

  # Unlike #balance, this balances Ripper tokens to balance something like `{ a: "}" }` correctly.
  #
  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#849
  def balance_tokens(buf, start, finish, count: T.unsafe(nil)); end

  # source://haml//lib/haml/parser.rb#316
  def block_keyword(text); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#867
  def block_opened?; end

  # source://haml//lib/haml/parser.rb#387
  def check_push_script_stack(keyword); end

  # source://haml//lib/haml/parser.rb#543
  def close; end

  # source://haml//lib/haml/parser.rb#549
  def close_filter(_); end

  # source://haml//lib/haml/parser.rb#557
  def close_flat_section; end

  # source://haml//lib/haml/parser.rb#553
  def close_haml_comment(_); end

  # source://haml//lib/haml/parser.rb#563
  def close_script(node); end

  # source://haml//lib/haml/parser.rb#563
  def close_silent_script(node); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#798
  def closes_flat?(line); end

  # Renders an XHTML comment.
  #
  # source://haml//lib/haml/parser.rb#498
  def comment(text); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#267
  def continuation_script?(text); end

  # Renders a line that creates an XHTML tag and has an implicit div because of
  # `.` or `#`.
  #
  # source://haml//lib/haml/parser.rb#492
  def div(line); end

  # Renders an XHTML doctype or XML shebang.
  #
  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#524
  def doctype(text); end

  # source://haml//lib/haml/parser.rb#196
  def error_with_lineno(error); end

  # @raise [Error]
  #
  # source://haml//lib/haml/parser.rb#530
  def filter(name); end

  # Same semantics as block_opened?, except that block_opened? uses Line#tabs,
  # which doesn't interact well with filter lines
  #
  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#873
  def filter_opened?; end

  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#877
  def flat?; end

  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#352
  def flat_script(line, escape_html = T.unsafe(nil)); end

  # source://haml//lib/haml/parser.rb#397
  def haml_comment(text); end

  # source://haml//lib/haml/parser.rb#802
  def handle_multiline(line); end

  # source://haml//lib/haml/parser.rb#820
  def handle_ruby_multiline(line); end

  # Checks whether or not `line` is in a multiline sequence.
  #
  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#816
  def is_multiline?(text); end

  # `text' is a Ruby multiline block if it:
  # - ends with a comma
  # - but not "?," which is a character literal
  #   (however, "x?," is a method call and not a literal)
  # - and not "?\," which is a character literal
  #
  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#839
  def is_ruby_multiline?(text); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/parser.rb#271
  def mid_block_keyword?(text); end

  # source://haml//lib/haml/parser.rb#780
  def next_line; end

  # source://haml//lib/haml/parser.rb#751
  def parse_new_attribute(scanner); end

  # @return [Array<Hash,String,nil>] - [static_attributes (Hash), dynamic_attributes (nil or String starting with `{` and ending with `}`)]
  # @return [String] rest
  # @return [Integer] last_line
  #
  # source://haml//lib/haml/parser.rb#710
  def parse_new_attributes(text); end

  # @return [String] attributes_hash - Hash literal starting with `{` and ending with `}`
  # @return [String] rest
  # @return [Integer] last_line
  #
  # source://haml//lib/haml/parser.rb#682
  def parse_old_attributes(text); end

  # This method doesn't use Haml::HamlAttributeParser because currently it depends on Ripper and Rubinius doesn't provide it.
  # Ideally this logic should be placed in Haml::HamlAttributeParser instead of here and this method should use it.
  #
  # @param text [String] - Hash literal or text inside old attributes
  # @return [Hash, nil] - Return nil if text is not static Hash literal
  #
  # source://haml//lib/haml/parser.rb#609
  def parse_static_hash(text); end

  # Parses a line into tag_name, attributes, attributes_hash, object_ref, action, value
  #
  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#627
  def parse_tag(text); end

  # source://haml//lib/haml/parser.rb#326
  def plain(line, escape_html = T.unsafe(nil)); end

  # Processes and deals with lowering indentation.
  #
  # source://haml//lib/haml/parser.rb#260
  def process_indent(line); end

  # Processes a single line of Haml.
  #
  # This method doesn't return anything; it simply processes the line and
  # adds the appropriate code to `@precompiled`.
  #
  # source://haml//lib/haml/parser.rb#279
  def process_line(line); end

  # source://haml//lib/haml/parser.rb#321
  def push(node); end

  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#340
  def script(line, escape_html = T.unsafe(nil), preserve = T.unsafe(nil)); end

  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#357
  def silent_script(line); end

  # @raise [SyntaxError]
  #
  # source://haml//lib/haml/parser.rb#410
  def tag(line); end

  class << self
    # This is a class method so it can be accessed from {Haml::HamlHelpers}.
    #
    # Iterates through the classes and ids supplied through `.`
    # and `#` syntax, and returns a hash with them as attributes,
    # that can then be merged with another attributes hash.
    #
    # source://haml//lib/haml/parser.rb#585
    def parse_class_and_id(list); end
  end
end

# source://haml//lib/haml/parser.rb#85
Haml::Parser::BLOCK_KEYWORD_REGEX = T.let(T.unsafe(nil), Regexp)

# Regex to check for blocks with spaces around arguments. Not to be confused
# with multiline script.
# For example:
#     foo.each do | bar |
#       = bar
#
# source://haml//lib/haml/parser.rb#79
Haml::Parser::BLOCK_WITH_SPACES = T.let(T.unsafe(nil), Regexp)

# source://haml//lib/haml/parser.rb#94
Haml::Parser::CLASS_KEY = T.let(T.unsafe(nil), String)

# Designates an XHTML/XML comment.
#
# source://haml//lib/haml/parser.rb#24
Haml::Parser::COMMENT = T.let(T.unsafe(nil), String)

# Designates a `<div>` element with the given class.
#
# source://haml//lib/haml/parser.rb#18
Haml::Parser::DIV_CLASS = T.let(T.unsafe(nil), String)

# Designates a `<div>` element with the given id.
#
# source://haml//lib/haml/parser.rb#21
Haml::Parser::DIV_ID = T.let(T.unsafe(nil), String)

# Designates an XHTML doctype or script that is never HTML-escaped.
#
# source://haml//lib/haml/parser.rb#27
Haml::Parser::DOCTYPE = T.let(T.unsafe(nil), String)

# The Regex that matches a Doctype command.
#
# source://haml//lib/haml/parser.rb#88
Haml::Parser::DOCTYPE_REGEX = T.let(T.unsafe(nil), Regexp)

# @param new [String] - Hash literal including dynamic values.
# @param old [String] - Hash literal including dynamic values or Ruby literal of multiple Hashes which MUST be interpreted as method's last arguments.
#
# source://haml//lib/haml/parser.rb#236
class Haml::Parser::DynamicAttributes < ::Struct
  # Returns the value of attribute new
  #
  # @return [Object] the current value of new
  def new; end

  # Sets the attribute new
  #
  # @param value [Object] the value to set the attribute new to.
  # @return [Object] the newly set value
  def new=(_); end

  # Returns the value of attribute old
  #
  # @return [Object] the current value of old
  def old; end

  # Sets the attribute old
  #
  # @param value [Object] the value to set the attribute old to.
  # @return [Object] the newly set value
  #
  # source://haml//lib/haml/parser.rb#238
  def old=(value); end

  # This will be a literal for Haml::HamlBuffer#attributes's last argument, `attributes_hashes`.
  #
  # source://haml//lib/haml/parser.rb#246
  def to_literal; end

  private

  # For `%foo{ { foo: 1 }, bar: 2 }`, :old is "{ { foo: 1 }, bar: 2 }" and this method returns " { foo: 1 }, bar: 2 " for last argument.
  #
  # source://haml//lib/haml/parser.rb#253
  def stripped_old; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Designates an XHTML/XML element.
#
# source://haml//lib/haml/parser.rb#15
Haml::Parser::ELEMENT = T.let(T.unsafe(nil), String)

# Designates a non-parsed line.
#
# source://haml//lib/haml/parser.rb#45
Haml::Parser::ESCAPE = T.let(T.unsafe(nil), String)

# Designates a block of filtered text.
#
# source://haml//lib/haml/parser.rb#48
Haml::Parser::FILTER = T.let(T.unsafe(nil), String)

# Designates script, the result of which is flattened and output.
#
# source://haml//lib/haml/parser.rb#36
Haml::Parser::FLAT_SCRIPT = T.let(T.unsafe(nil), String)

# source://haml//lib/haml/parser.rb#93
Haml::Parser::ID_KEY = T.let(T.unsafe(nil), String)

# The Regex that matches a literal string or symbol value
#
# source://haml//lib/haml/parser.rb#91
Haml::Parser::LITERAL_VALUE_REGEX = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://haml//lib/haml/parser.rb#207
class Haml::Parser::Line < ::Struct
  # Returns the value of attribute eod
  #
  # @return [Object] the current value of eod
  def eod; end

  # Sets the attribute eod
  #
  # @param value [Object] the value to set the attribute eod to.
  # @return [Object] the newly set value
  def eod=(_); end

  # Returns the value of attribute eod
  #
  # @return [Object] the current value of eod
  def eod?; end

  # Returns the value of attribute full
  #
  # @return [Object] the current value of full
  def full; end

  # Sets the attribute full
  #
  # @param value [Object] the value to set the attribute full to.
  # @return [Object] the newly set value
  def full=(_); end

  # Returns the value of attribute index
  #
  # @return [Object] the current value of index
  def index; end

  # Sets the attribute index
  #
  # @param value [Object] the value to set the attribute index to.
  # @return [Object] the newly set value
  def index=(_); end

  # Returns the value of attribute parser
  #
  # @return [Object] the current value of parser
  def parser; end

  # Sets the attribute parser
  #
  # @param value [Object] the value to set the attribute parser to.
  # @return [Object] the newly set value
  def parser=(_); end

  # source://haml//lib/haml/parser.rb#215
  def strip!(from); end

  # @private
  #
  # source://haml//lib/haml/parser.rb#211
  def tabs; end

  # Returns the value of attribute text
  #
  # @return [Object] the current value of text
  def text; end

  # Sets the attribute text
  #
  # @param value [Object] the value to set the attribute text to.
  # @return [Object] the newly set value
  def text=(_); end

  # Returns the value of attribute whitespace
  #
  # @return [Object] the current value of whitespace
  def whitespace; end

  # Sets the attribute whitespace
  #
  # @param value [Object] the value to set the attribute whitespace to.
  # @return [Object] the newly set value
  def whitespace=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Used for scanning old attributes, substituting the first '{'
#
# source://haml//lib/haml/parser.rb#97
Haml::Parser::METHOD_CALL_PREFIX = T.let(T.unsafe(nil), String)

# source://haml//lib/haml/parser.rb#81
Haml::Parser::MID_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# The value of the character that designates that a line is part
# of a multiline string.
#
# source://haml//lib/haml/parser.rb#71
Haml::Parser::MULTILINE_CHAR_VALUE = T.let(T.unsafe(nil), String)

# Designates a non-parsed line. Not actually a character.
#
# source://haml//lib/haml/parser.rb#51
Haml::Parser::PLAIN_TEXT = T.let(T.unsafe(nil), Integer)

# @private
#
# source://haml//lib/haml/parser.rb#223
class Haml::Parser::ParseNode < ::Struct
  # @return [ParseNode] a new instance of ParseNode
  #
  # source://haml//lib/haml/parser.rb#224
  def initialize(*args); end

  # source://syntax_tree-haml/3.0.0/lib/syntax_tree/haml.rb#60
  def accept(visitor); end

  # Returns the value of attribute children
  #
  # @return [Object] the current value of children
  def children; end

  # Sets the attribute children
  #
  # @param value [Object] the value to set the attribute children to.
  # @return [Object] the newly set value
  def children=(_); end

  # source://syntax_tree-haml/3.0.0/lib/syntax_tree/haml.rb#85
  def format(q); end

  # source://haml//lib/haml/parser.rb#229
  def inspect; end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute parent
  #
  # @return [Object] the current value of parent
  def parent; end

  # Sets the attribute parent
  #
  # @param value [Object] the value to set the attribute parent to.
  # @return [Object] the newly set value
  def parent=(_); end

  # source://syntax_tree-haml/3.0.0/lib/syntax_tree/haml.rb#89
  def pretty_print(q); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://haml//lib/haml/parser.rb#952
class Haml::Parser::ParserOptions
  # @return [ParserOptions] a new instance of ParserOptions
  #
  # source://haml//lib/haml/parser.rb#980
  def initialize(values = T.unsafe(nil)); end

  # source://haml//lib/haml/parser.rb#964
  def autoclose; end

  # source://haml//lib/haml/parser.rb#964
  def escape_html; end

  # source://haml//lib/haml/parser.rb#964
  def filename; end

  # source://haml//lib/haml/parser.rb#964
  def line; end

  # source://haml//lib/haml/parser.rb#964
  def mime_type; end

  # source://haml//lib/haml/parser.rb#964
  def preserve; end

  # source://haml//lib/haml/parser.rb#964
  def remove_whitespace; end

  # source://haml//lib/haml/parser.rb#964
  def suppress_eval; end
end

# A list of options that are actually used in the parser
#
# source://haml//lib/haml/parser.rb#954
Haml::Parser::ParserOptions::AVAILABLE_OPTIONS = T.let(T.unsafe(nil), Array)

# source://haml//lib/haml/parser.rb#967
Haml::Parser::ParserOptions::DEFAULTS = T.let(T.unsafe(nil), Hash)

# Designates script that is always HTML-escaped.
#
# source://haml//lib/haml/parser.rb#33
Haml::Parser::SANITIZE = T.let(T.unsafe(nil), String)

# Designates script, the result of which is output.
#
# source://haml//lib/haml/parser.rb#30
Haml::Parser::SCRIPT = T.let(T.unsafe(nil), String)

# When following SILENT_SCRIPT, designates a comment that is not output.
#
# source://haml//lib/haml/parser.rb#42
Haml::Parser::SILENT_COMMENT = T.let(T.unsafe(nil), String)

# Designates script which is run but not output.
#
# source://haml//lib/haml/parser.rb#39
Haml::Parser::SILENT_SCRIPT = T.let(T.unsafe(nil), String)

# Keeps track of the ASCII values of the characters that begin a
# specially-interpreted line.
#
# source://haml//lib/haml/parser.rb#55
Haml::Parser::SPECIAL_CHARACTERS = T.let(T.unsafe(nil), Array)

# source://haml//lib/haml/parser.rb#82
Haml::Parser::START_BLOCK_KEYWORDS = T.let(T.unsafe(nil), Array)

# Try to parse assignments to block starters as best as possible
#
# source://haml//lib/haml/parser.rb#84
Haml::Parser::START_BLOCK_KEYWORD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://haml//lib/haml/ruby_expression.rb#5
class Haml::RubyExpression < ::Ripper
  private

  # @raise [ParseError]
  #
  # source://haml//lib/haml/ruby_expression.rb#28
  def on_parse_error(*_arg0); end

  class << self
    # @return [Boolean]
    #
    # source://haml//lib/haml/ruby_expression.rb#15
    def string_literal?(code); end

    # @return [Boolean]
    #
    # source://haml//lib/haml/ruby_expression.rb#8
    def syntax_error?(code); end
  end
end

# source://haml//lib/haml/ruby_expression.rb#6
class Haml::RubyExpression::ParseError < ::StandardError; end

# Compile [:dynamic, "foo#{bar}"] to [:multi, [:static, 'foo'], [:dynamic, 'bar']]
#
# source://haml//lib/haml/string_splitter.rb#9
class Haml::StringSplitter < ::Temple::Filter
  # source://haml//lib/haml/string_splitter.rb#88
  def on_dynamic(code); end

  private

  # @return [Boolean]
  #
  # source://haml//lib/haml/string_splitter.rb#106
  def string_literal?(code); end

  class << self
    # `code` param must be valid string literal
    #
    # source://haml//lib/haml/string_splitter.rb#13
    def compile(code); end

    private

    # source://haml//lib/haml/string_splitter.rb#41
    def compile_tokens!(exps, tokens); end

    # Some quotes are split-unsafe. Replace such quotes with null characters.
    #
    # source://haml//lib/haml/string_splitter.rb#59
    def escape_quotes(beg_str, end_str); end

    # source://haml//lib/haml/string_splitter.rb#68
    def shift_balanced_embexpr(tokens); end

    # source://haml//lib/haml/string_splitter.rb#27
    def strip_quotes!(tokens); end
  end
end

# source://haml//lib/haml/string_splitter.rb#117
class Haml::StringSplitter::SyntaxChecker < ::Ripper
  private

  # @raise [ParseError]
  #
  # source://haml//lib/haml/string_splitter.rb#129
  def on_parse_error(*_arg0); end

  class << self
    # @return [Boolean]
    #
    # source://haml//lib/haml/string_splitter.rb#120
    def syntax_error?(code); end
  end
end

# source://haml//lib/haml/string_splitter.rb#118
class Haml::StringSplitter::SyntaxChecker::ParseError < ::StandardError; end

# SyntaxError is the type of exception raised when Haml encounters an
# ill-formatted document.
# It's not particularly interesting,
# except in that it's a subclass of {Haml::Error}.
#
# source://haml//lib/haml/error.rb#59
class Haml::SyntaxError < ::Haml::Error; end

# source://haml//lib/haml/template.rb#0
class Haml::Template < ::Temple::Templates::Tilt
  extend ::Haml::TemplateExtension
end

# source://haml//lib/haml/template.rb#12
module Haml::TemplateExtension
  # Activate Haml::Helpers for tilt templates.
  # https://github.com/judofyr/temple/blob/v0.7.6/lib/temple/mixins/template.rb#L7-L11
  #
  # source://haml//lib/haml/template.rb#15
  def compile(*_arg0); end
end

# For backward compatibility of Tilt integration. TODO: We should deprecate this
# and let Tilt have a native support of Haml 6. At least it generates warnings now.
#
# source://haml//lib/haml/engine.rb#50
class Haml::TempleEngine < ::Haml::Engine
  # source://haml//lib/haml/engine.rb#51
  def compile(template); end

  # source://haml//lib/haml/engine.rb#55
  def precompiled_with_ambles(_local_names, after_preamble:); end
end

# A module to count lines of expected code. This would be faster than actual code generation
# and counting newlines in it.
#
# source://haml//lib/haml/temple_line_counter.rb#5
module Haml::TempleLineCounter
  class << self
    # source://haml//lib/haml/temple_line_counter.rb#8
    def count_lines(exp); end
  end
end

# source://haml//lib/haml/temple_line_counter.rb#6
class Haml::TempleLineCounter::UnexpectedExpression < ::StandardError; end

# A module containing various useful functions.
#
# source://haml//lib/haml/util.rb#14
module Haml::Util
  extend ::Haml::Util

  # Moves a scanner through a balanced pair of characters.
  # For example:
  #
  #     Foo (Bar (Baz bang) bop) (Bang (bop bip))
  #     ^                       ^
  #     from                    to
  #
  # @param scanner [StringScanner] The string scanner to move
  # @param start [String] The character opening the balanced pair.
  # @param finish [String] The character closing the balanced pair.
  # @param count [Fixnum] The number of opening characters matched
  #   before calling this method
  # @return [(String, String)] The string matched within the balanced pair
  #   and the rest of the string.
  #   `["Foo (Bar (Baz bang) bop)", " (Bang (bop bip))"]` in the example above.
  #
  # source://haml//lib/haml/util.rb#171
  def balance(scanner, start, finish, count = T.unsafe(nil)); end

  # Checks that the encoding of a string is valid
  # and cleans up potential encoding gotchas like the UTF-8 BOM.
  # If it's not, yields an error string describing the invalid character
  # and the line on which it occurs.
  #
  # @param str [String] The string of which to check the encoding
  # @return [String] `str`, potentially with encoding gotchas like BOMs removed
  # @yield [msg] A block in which an encoding error can be raised.
  #   Only yields if there is an encoding error
  # @yieldparam msg [String] The error message to be raised
  #
  # source://haml//lib/haml/util.rb#65
  def check_encoding(str); end

  # Like {\#check\_encoding}, but also checks for a Ruby-style `-# coding:` comment
  # at the beginning of the template and uses that encoding if it exists.
  #
  # The Haml encoding rules are simple.
  # If a `-# coding:` comment exists,
  # we assume that that's the original encoding of the document.
  # Otherwise, we use whatever encoding Ruby has.
  #
  # Haml uses the same rules for parsing coding comments as Ruby.
  # This means that it can understand Emacs-style comments
  # and also that it cannot understand non-ASCII-compatible encodings
  # such as `UTF-16` and `UTF-32`.
  #
  # @param str [String] The Haml template of which to check the encoding
  # @raise [ArgumentError] if the document declares an unknown encoding
  # @return [String] The original string encoded properly
  # @yield [msg] A block in which an encoding error can be raised.
  #   Only yields if there is an encoding error
  # @yieldparam msg [String] The error message to be raised
  #
  # source://haml//lib/haml/util.rb#112
  def check_haml_encoding(str, &block); end

  # @return [Boolean]
  #
  # source://haml//lib/haml/util.rb#200
  def contains_interpolation?(str); end

  # Scans through a string looking for the interoplation-opening `#{`
  # and, when it's found, yields the scanner to the calling code
  # so it can handle it properly.
  #
  # The scanner will have any backslashes immediately in front of the `#{`
  # as the second capture group (`scan[2]`),
  # and the text prior to that as the first (`scan[1]`).
  #
  # @return [String] The text remaining in the scanner after all `#{`s have been processed
  # @yieldparam scan [StringScanner] The scanner scanning through the string
  #
  # source://haml//lib/haml/util.rb#150
  def handle_interpolation(str); end

  # Formats a string for use in error messages about indentation.
  #
  # @param indentation [String] The string used for indentation
  # @return [String] The name of the indentation (e.g. `"12 spaces"`, `"1 tab"`)
  #
  # source://haml//lib/haml/util.rb#187
  def human_indentation(indentation); end

  # Like `Object#inspect`, but preserves non-ASCII characters rather than escaping them.
  # This is necessary so that the precompiled Haml template can be `#encode`d into `@options[:encoding]`
  # before being evaluated.
  #
  # @param obj [Object]
  # @return [String]
  #
  # source://haml//lib/haml/util.rb#129
  def inspect_obj(obj); end

  # Whether or not ActionView's XSS protection is available and enabled,
  # as is the default for Rails 3.0+, and optional for version 2.3.5+.
  # Overridden in haml/template.rb if this is the case.
  #
  # @return [Boolean]
  #
  # source://haml//lib/haml/util.rb#51
  def rails_xss_safe?; end

  # Silence all output to STDERR within a block.
  #
  # @yield A block in which no output will be printed to STDERR
  #
  # source://haml//lib/haml/util.rb#37
  def silence_warnings; end

  # source://haml//lib/haml/util.rb#204
  def unescape_interpolation(str, escape_html = T.unsafe(nil)); end

  private

  # Parses a magic comment at the beginning of a Haml file.
  # The parsing rules are basically the same as Ruby's.
  #
  # @return [(Boolean, String or nil)] Whether the document begins with a UTF-8 BOM,
  #   and the declared encoding of the document (or nil if none is declared)
  #
  # source://haml//lib/haml/util.rb#236
  def parse_haml_magic_comment(str); end

  # source://haml//lib/haml/util.rb#248
  def try_parse_haml_emacs_magic_comment(scanner); end

  class << self
    def escape_html(_arg0); end

    # TODO: Remove unescape_interpolation's workaround and get rid of `respond_to?`.
    #
    # source://haml//lib/haml/util.rb#29
    def escape_html_safe(html); end
  end
end

# source://haml//lib/haml/version.rb#3
Haml::VERSION = T.let(T.unsafe(nil), String)

# source://haml//lib/haml/whitespace.rb#3
class Haml::Whitespace < ::Temple::Filter
  # source://haml//lib/haml/whitespace.rb#4
  def on_whitespace; end
end

class Temple::Filter
  include ::Temple::Mixins::CompiledDispatcher
  include ::Temple::Mixins::CoreDispatcher
  include ::Temple::Mixins::EscapeDispatcher
  include ::Temple::Mixins::ControlFlowDispatcher
  include ::Haml::EscapeanyDispathcer
  include ::Haml::FescapeDispathcer
end
