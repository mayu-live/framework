# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `async` gem.
# Please instead update this file by running `bin/tapioca gem async`.

# source://async//lib/async/clock.rb#23
module Async; end

# A synchronization primitive, which allows one task to wait for a number of other tasks to complete. It can be used in conjunction with {Semaphore}.
#
# source://async//lib/async/barrier.rb#28
class Async::Barrier
  # Initialize the barrier.
  #
  # @return [Barrier] a new instance of Barrier
  #
  # source://async//lib/async/barrier.rb#32
  def initialize(parent: T.unsafe(nil)); end

  # Execute a child task and add it to the barrier.
  #
  # source://async//lib/async/barrier.rb#48
  def async(*arguments, parent: T.unsafe(nil), **options, &block); end

  # Whether there are any tasks being held by the barrier.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/barrier.rb#58
  def empty?; end

  # The number of tasks currently held by the barrier.
  #
  # source://async//lib/async/barrier.rb#42
  def size; end

  # Stop all tasks held by the barrier.
  #
  # source://async//lib/async/barrier.rb#83
  def stop; end

  # All tasks which have been invoked into the barrier.
  #
  # source://async//lib/async/barrier.rb#39
  def tasks; end

  # Wait for all tasks.
  #
  # source://async//lib/async/barrier.rb#64
  def wait; end
end

# A list of children tasks.
#
# source://async//lib/async/node.rb#125
class Async::Children < ::Async::List
  # @return [Children] a new instance of Children
  #
  # source://async//lib/async/node.rb#126
  def initialize; end

  # source://async//lib/async/node.rb#145
  def delete(item); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#153
  def finished?; end

  # source://async//lib/async/node.rb#137
  def insert(item); end

  # Does this node have (direct) transient children?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#133
  def transients?; end
end

# A convenient wrapper around the internal monotonic clock.
#
# source://async//lib/async/clock.rb#26
class Async::Clock
  # Create a new clock with the initial total time.
  #
  # @return [Clock] a new instance of Clock
  #
  # source://async//lib/async/clock.rb#51
  def initialize(total = T.unsafe(nil)); end

  # Start measuring a duration.
  #
  # source://async//lib/async/clock.rb#57
  def start!; end

  # Stop measuring a duration and append the duration to the current total.
  #
  # source://async//lib/async/clock.rb#62
  def stop!; end

  # The total elapsed time including any current duration.
  #
  # source://async//lib/async/clock.rb#72
  def total; end

  class << self
    # Measure the execution of a block of code.
    #
    # source://async//lib/async/clock.rb#35
    def measure; end

    # Get the current elapsed monotonic time.
    #
    # source://async//lib/async/clock.rb#28
    def now; end

    # Start measuring elapsed time from now.
    #
    # source://async//lib/async/clock.rb#45
    def start; end
  end
end

# A synchronization primitive, which allows fibers to wait until a particular condition is (edge) triggered.
#
# source://async//lib/async/condition.rb#29
class Async::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://async//lib/async/condition.rb#30
  def initialize; end

  # Is any fiber waiting on this notification?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#63
  def empty?; end

  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/condition.rb#69
  def signal(value = T.unsafe(nil)); end

  # Queue up the current fiber and wait on yielding the task.
  #
  # source://async//lib/async/condition.rb#52
  def wait; end
end

# source://async//lib/async/condition.rb#34
class Async::Condition::Queue < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/condition.rb#39
  def alive?; end

  # Returns the value of attribute fiber
  #
  # @return [Object] the current value of fiber
  def fiber; end

  # Sets the attribute fiber
  #
  # @param value [Object] the value to set the attribute fiber to.
  # @return [Object] the newly set value
  def fiber=(_); end

  # source://async//lib/async/condition.rb#43
  def nullify; end

  # source://async//lib/async/condition.rb#35
  def transfer(*arguments); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://async//lib/async/queue.rb#80
class Async::LimitedQueue < ::Async::Queue
  # @return [LimitedQueue] a new instance of LimitedQueue
  #
  # source://async//lib/async/queue.rb#81
  def initialize(limit = T.unsafe(nil), **options); end

  # source://async//lib/async/queue.rb#96
  def <<(item); end

  # source://async//lib/async/queue.rb#117
  def dequeue; end

  # source://async//lib/async/queue.rb#104
  def enqueue(*items); end

  # Returns the value of attribute limit.
  #
  # source://async//lib/async/queue.rb#89
  def limit; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#92
  def limited?; end
end

# A double linked list used for managing tasks.
#
# source://async//lib/async/node.rb#25
class Async::List
  # @return [List] a new instance of List
  #
  # source://async//lib/async/node.rb#26
  def initialize; end

  # source://async//lib/async/node.rb#62
  def delete(item); end

  # source://async//lib/async/node.rb#83
  def each(&block); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#113
  def empty?; end

  # source://async//lib/async/node.rb#105
  def first; end

  # Returns the value of attribute head.
  #
  # source://async//lib/async/node.rb#35
  def head; end

  # Sets the attribute head
  #
  # @param value the value to set the attribute head to.
  #
  # source://async//lib/async/node.rb#35
  def head=(_arg0); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#97
  def include?(needle); end

  # Inserts an item at the end of the list.
  #
  # source://async//lib/async/node.rb#39
  def insert(item); end

  # source://async//lib/async/node.rb#109
  def last; end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#117
  def nil?; end

  # Returns the value of attribute size.
  #
  # source://async//lib/async/node.rb#33
  def size; end

  # Returns the value of attribute tail.
  #
  # source://async//lib/async/node.rb#36
  def tail; end

  # Sets the attribute tail
  #
  # @param value the value to set the attribute tail to.
  #
  # source://async//lib/async/node.rb#36
  def tail=(_arg0); end
end

# A node in a tree, used for implementing the task hierarchy.
#
# source://async//lib/async/node.rb#159
class Async::Node
  # Create a new node in the tree.
  #
  # @return [Node] a new instance of Node
  #
  # source://async//lib/async/node.rb#162
  def initialize(parent = T.unsafe(nil), annotation: T.unsafe(nil), transient: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#209
  def annotate(annotation); end

  # A useful identifier for the current node.
  #
  # source://async//lib/async/node.rb#197
  def annotation; end

  # source://async//lib/async/node.rb#232
  def backtrace(*arguments); end

  # Returns the value of attribute children.
  #
  # source://async//lib/async/node.rb#194
  def children; end

  # Whether there are children?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#200
  def children?; end

  # If the node has a parent, and is {finished?}, then remove this node from
  # the parent.
  #
  # source://async//lib/async/node.rb#284
  def consume; end

  # source://async//lib/async/node.rb#220
  def description; end

  # Whether the node can be consumed safely. By default, checks if the
  # children set is empty.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#278
  def finished?; end

  # @private
  #
  # source://async//lib/async/node.rb#185
  def head; end

  # @private
  #
  # source://async//lib/async/node.rb#185
  def head=(_arg0); end

  # source://async//lib/async/node.rb#236
  def inspect; end

  # Returns the value of attribute parent.
  #
  # source://async//lib/async/node.rb#191
  def parent; end

  # Change the parent of this node.
  #
  # source://async//lib/async/node.rb#245
  def parent=(parent); end

  # source://async//lib/async/node.rb#347
  def print_hierarchy(out = T.unsafe(nil), backtrace: T.unsafe(nil)); end

  # source://async//lib/async/node.rb#180
  def root; end

  # Attempt to stop the current node immediately, including all non-transient children.
  # Invokes {#stop_children} to stop all children.
  #
  # source://async//lib/async/node.rb#331
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#343
  def stopped?; end

  # @private
  #
  # source://async//lib/async/node.rb#188
  def tail; end

  # @private
  #
  # source://async//lib/async/node.rb#188
  def tail=(_arg0); end

  # Immediately terminate all children tasks, including transient tasks.
  # Internally invokes `stop(false)` on all children.
  #
  # source://async//lib/async/node.rb#318
  def terminate; end

  # source://async//lib/async/node.rb#236
  def to_s; end

  # Is this node transient?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/node.rb#205
  def transient?; end

  # Traverse the tree.
  #
  # @yield [_self, level]
  # @yieldparam _self [Async::Node] the object that the method was called on
  #
  # source://async//lib/async/node.rb#308
  def traverse(level = T.unsafe(nil), &block); end

  protected

  # source://async//lib/async/node.rb#264
  def add_child(child); end

  # source://async//lib/async/node.rb#270
  def delete_child(child); end

  # source://async//lib/async/node.rb#260
  def set_parent(parent); end

  private

  # source://async//lib/async/node.rb#359
  def print_backtrace(out, indent, node); end

  # Attempt to stop all non-transient children.
  #
  # source://async//lib/async/node.rb#337
  def stop_children(later = T.unsafe(nil)); end
end

# A synchronization primitive, which allows fibers to wait until a notification is received. Does not block the task which signals the notification. Waiting tasks are resumed on next iteration of the reactor.
#
# source://async//lib/async/notification.rb#29
class Async::Notification < ::Async::Condition
  # Signal to a given task that it should resume operations.
  #
  # source://async//lib/async/notification.rb#30
  def signal(value = T.unsafe(nil), task: T.unsafe(nil)); end
end

# source://async//lib/async/notification.rb#40
class Async::Notification::Signal < ::Struct
  # @return [Boolean]
  #
  # source://async//lib/async/notification.rb#41
  def alive?; end

  # source://async//lib/async/notification.rb#45
  def transfer; end

  # Returns the value of attribute value
  #
  # @return [Object] the current value of value
  def value; end

  # Sets the attribute value
  #
  # @param value [Object] the value to set the attribute value to.
  # @return [Object] the newly set value
  def value=(_); end

  # Returns the value of attribute waiting
  #
  # @return [Object] the current value of waiting
  def waiting; end

  # Sets the attribute waiting
  #
  # @param value [Object] the value to set the attribute waiting to.
  # @return [Object] the newly set value
  def waiting=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# A queue which allows items to be processed in order.
#
# source://async//lib/async/queue.rb#28
class Async::Queue < ::Async::Notification
  # @return [Queue] a new instance of Queue
  #
  # source://async//lib/async/queue.rb#29
  def initialize(parent: T.unsafe(nil)); end

  # source://async//lib/async/queue.rb#46
  def <<(item); end

  # source://async//lib/async/queue.rb#66
  def async(parent: T.unsafe(nil), &block); end

  # source://async//lib/async/queue.rb#58
  def dequeue; end

  # source://async//lib/async/queue.rb#72
  def each; end

  # @return [Boolean]
  #
  # source://async//lib/async/queue.rb#42
  def empty?; end

  # source://async//lib/async/queue.rb#52
  def enqueue(*items); end

  # Returns the value of attribute items.
  #
  # source://async//lib/async/queue.rb#36
  def items; end

  # source://async//lib/async/queue.rb#38
  def size; end
end

# A wrapper around the the scheduler which binds it to the current thread automatically.
#
# source://async//lib/async/reactor.rb#26
class Async::Reactor < ::Async::Scheduler
  # @return [Reactor] a new instance of Reactor
  #
  # source://async//lib/async/reactor.rb#31
  def initialize(*_arg0, **_arg1, &_arg2); end

  class << self
    # @deprecated Replaced by {Kernel::Async}.
    #
    # source://async//lib/async/reactor.rb#27
    def run(*_arg0, **_arg1, &_arg2); end
  end
end

# Handles scheduling of fibers. Implements the fiber scheduler interface.
#
# source://async//lib/async/scheduler.rb#34
class Async::Scheduler < ::Async::Node
  # @return [Scheduler] a new instance of Scheduler
  #
  # source://async//lib/async/scheduler.rb#39
  def initialize(parent = T.unsafe(nil), selector: T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#151
  def address_resolve(hostname); end

  # Start an asynchronous task within the specified reactor. The task will be
  # executed until the first blocking call, at which point it will yield and
  # and this method will return.
  #
  # This is the main entry point for scheduling asynchronus tasks.
  #
  # @deprecated With no replacement.
  #
  # source://async//lib/async/scheduler.rb#259
  def async(*arguments, **options, &block); end

  # Invoked when a fiber tries to perform a blocking operation which cannot continue. A corresponding call {unblock} must be performed to allow this fiber to continue.
  #
  # source://async//lib/async/scheduler.rb#110
  def block(blocker, timeout); end

  # source://async//lib/async/scheduler.rb#51
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/scheduler.rb#70
  def closed?; end

  # source://async//lib/async/scheduler.rb#275
  def fiber(*_arg0, **_arg1, &_arg2); end

  # Interrupt the event loop and cause it to exit.
  #
  # source://async//lib/async/scheduler.rb#79
  def interrupt; end

  # source://async//lib/async/scheduler.rb#177
  def io_read(io, buffer, length); end

  # source://async//lib/async/scheduler.rb#156
  def io_wait(io, events, timeout = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#181
  def io_write(io, buffer, length); end

  # source://async//lib/async/scheduler.rb#142
  def kernel_sleep(duration = T.unsafe(nil)); end

  # Wait for the specified process ID to exit.
  #
  # source://async//lib/async/scheduler.rb#191
  def process_wait(pid, flags); end

  # Schedule a fiber (or equivalent object) to be resumed on the next loop through the reactor.
  #
  # source://async//lib/async/scheduler.rb#96
  def push(fiber); end

  # source://async//lib/async/scheduler.rb#100
  def raise(*arguments); end

  # source://async//lib/async/scheduler.rb#104
  def resume(fiber, *arguments); end

  # Run the reactor until all tasks are finished. Proxies arguments to {#async} immediately before entering the loop, if a block is provided.
  #
  # source://async//lib/async/scheduler.rb#232
  def run(*_arg0, **_arg1, &_arg2); end

  # Run one iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#198
  def run_once(timeout = T.unsafe(nil)); end

  # source://async//lib/async/scheduler.rb#295
  def timeout_after(duration, exception, message, &block); end

  # source://async//lib/async/scheduler.rb#74
  def to_s; end

  # Transfer from the calling fiber to the event loop.
  #
  # source://async//lib/async/scheduler.rb#85
  def transfer; end

  # source://async//lib/async/scheduler.rb#133
  def unblock(blocker, fiber); end

  # Invoke the block, but after the specified timeout, raise {TimeoutError} in any currenly blocking operation. If the block runs to completion before the timeout occurs or there are no non-blocking operations after the timeout expires, the code will complete without any exception.
  #
  # source://async//lib/async/scheduler.rb#281
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield the current fiber and resume it on the next iteration of the event loop.
  #
  # source://async//lib/async/scheduler.rb#90
  def yield; end

  class << self
    # Whether the fiber scheduler is supported.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/scheduler.rb#35
    def supported?; end
  end
end

# A synchronization primitive, which limits access to a given resource.
#
# source://async//lib/async/semaphore.rb#26
class Async::Semaphore
  # @return [Semaphore] a new instance of Semaphore
  #
  # source://async//lib/async/semaphore.rb#29
  def initialize(limit = T.unsafe(nil), parent: T.unsafe(nil)); end

  # Acquire the semaphore, block if we are at the limit.
  # If no block is provided, you must call release manually.
  #
  # source://async//lib/async/semaphore.rb#75
  def acquire; end

  # Run an async task. Will wait until the semaphore is ready until spawning and running the task.
  #
  # source://async//lib/async/semaphore.rb#57
  def async(*arguments, parent: T.unsafe(nil), **options); end

  # Whether trying to acquire this semaphore would block.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#52
  def blocking?; end

  # The current number of tasks that have acquired the semaphore.
  #
  # source://async//lib/async/semaphore.rb#38
  def count; end

  # Is the semaphore currently acquired?
  #
  # @return [Boolean]
  #
  # source://async//lib/async/semaphore.rb#47
  def empty?; end

  # The maximum number of tasks that can acquire the semaphore.
  #
  # source://async//lib/async/semaphore.rb#41
  def limit; end

  # Release the semaphore. Must match up with a corresponding call to `acquire`. Will release waiting fibers in FIFO order.
  #
  # source://async//lib/async/semaphore.rb#90
  def release; end

  # The tasks waiting on this semaphore.
  #
  # source://async//lib/async/semaphore.rb#44
  def waiting; end

  private

  # Wait until the semaphore becomes available.
  #
  # source://async//lib/async/semaphore.rb#103
  def wait; end
end

# Raised when a task is explicitly stopped.
#
# source://async//lib/async/task.rb#30
class Async::Stop < ::Exception; end

# source://async//lib/async/task.rb#31
class Async::Stop::Later
  # @return [Later] a new instance of Later
  #
  # source://async//lib/async/task.rb#32
  def initialize(task); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#36
  def alive?; end

  # source://async//lib/async/task.rb#40
  def transfer; end
end

# Encapsulates the state of a running task and it's result.
#
# source://async//lib/async/task.rb#57
class Async::Task < ::Async::Node
  # Create a new task.
  #
  # @return [Task] a new instance of Task
  #
  # source://async//lib/async/task.rb#65
  def initialize(parent = T.unsafe(nil), finished: T.unsafe(nil), **options, &block); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#108
  def alive?; end

  # source://async//lib/async/task.rb#126
  def async(*arguments, **options, &block); end

  # source://async//lib/async/task.rb#81
  def backtrace(*arguments); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#220
  def complete?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#196
  def current?; end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#212
  def failed?; end

  # @attr fiber [Fiber] The fiber which is being used for the execution of this task.
  #
  # source://async//lib/async/task.rb#106
  def fiber; end

  # Whether we can remove this node from the reactor graph.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#208
  def finished?; end

  # source://async//lib/async/task.rb#76
  def reactor; end

  # Access the result of the task without waiting. May be nil if the task is not completed.
  #
  # source://async//lib/async/task.rb#154
  def result; end

  # Begin the execution of the task.
  #
  # source://async//lib/async/task.rb#116
  def run(*arguments); end

  # Check if the task is running.
  #
  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#202
  def running?; end

  # @deprecated Prefer {Kernel#sleep} except when compatibility with `stable-v1` is required.
  #
  # source://async//lib/async/task.rb#91
  def sleep(duration = T.unsafe(nil)); end

  # @attr status [Symbol] The status of the execution of the fiber, one of `:initialized`, `:running`, `:complete`, `:stopped` or `:failed`.
  #
  # source://async//lib/async/task.rb#113
  def status; end

  # Stop the task and all of its children.
  #
  # source://async//lib/async/task.rb#157
  def stop(later = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/task.rb#216
  def stopped?; end

  # source://async//lib/async/task.rb#86
  def to_s; end

  # Retrieve the current result of the task. Will cause the caller to wait until result is available.
  # @raises[RuntimeError] If the task's fiber is the current fiber.
  #
  # source://async//lib/async/task.rb#137
  def wait; end

  # Execute the given block of code, raising the specified exception if it exceeds the given duration during a non-blocking operation.
  #
  # source://async//lib/async/task.rb#96
  def with_timeout(duration, exception = T.unsafe(nil), message = T.unsafe(nil), &block); end

  # Yield back to the reactor and allow other fibers to execute.
  #
  # source://async//lib/async/task.rb#101
  def yield; end

  private

  # This is a very tricky aspect of tasks to get right. I've modelled it after `Thread` but it's slightly different in that the exception can propagate back up through the reactor. If the user writes code which raises an exception, that exception should always be visible, i.e. cause a failure. If it's not visible, such code fails silently and can be very difficult to debug.
  #
  # source://async//lib/async/task.rb#227
  def fail!(exception = T.unsafe(nil), propagate = T.unsafe(nil)); end

  # Finish the current task, and all bound bound IO objects.
  #
  # source://async//lib/async/task.rb#274
  def finish!; end

  # source://async//lib/async/task.rb#250
  def schedule(arguments); end

  # Set the current fiber's `:async_task` to this task.
  #
  # source://async//lib/async/task.rb#288
  def set!; end

  # source://async//lib/async/task.rb#243
  def stop!; end

  class << self
    # Lookup the {Task} for the current fiber. Raise `RuntimeError` if none is available.
    # @raises[RuntimeError] If task was not {set!} for the current fiber.
    #
    # source://async//lib/async/task.rb#186
    def current; end

    # Check if there is a task defined for the current fiber.
    #
    # @return [Boolean]
    #
    # source://async//lib/async/task.rb#192
    def current?; end

    # @deprecated With no replacement.
    #
    # source://async//lib/async/task.rb#58
    def yield; end
  end
end

# Raised if a timeout occurs on a specific Fiber. Handled gracefully by `Task`.
#
# source://async//lib/async/task.rb#48
class Async::TimeoutError < ::StandardError
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://async//lib/async/task.rb#49
  def initialize(message = T.unsafe(nil)); end
end

# source://async//lib/async/version.rb#24
Async::VERSION = T.let(T.unsafe(nil), String)

# source://async//lib/async/variable.rb#26
class Async::Variable
  # @return [Variable] a new instance of Variable
  #
  # source://async//lib/async/variable.rb#27
  def initialize(condition = T.unsafe(nil)); end

  # source://async//lib/async/variable.rb#32
  def resolve(value = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://async//lib/async/variable.rb#42
  def resolved?; end

  # source://async//lib/async/variable.rb#46
  def value; end

  # source://async//lib/async/variable.rb#51
  def wait; end
end

# Represents an asynchronous IO within a reactor.
#
# @deprecated With no replacement. Prefer native interfaces.
#
# source://async//lib/async/wrapper.rb#26
class Async::Wrapper
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://async//lib/async/wrapper.rb#33
  def initialize(io, reactor = T.unsafe(nil)); end

  # Close the io and monitor.
  #
  # source://async//lib/async/wrapper.rb#71
  def close; end

  # @return [Boolean]
  #
  # source://async//lib/async/wrapper.rb#75
  def closed?; end

  # source://async//lib/async/wrapper.rb#42
  def dup; end

  # The underlying native `io`.
  #
  # source://async//lib/async/wrapper.rb#47
  def io; end

  # Returns the value of attribute reactor.
  #
  # source://async//lib/async/wrapper.rb#40
  def reactor; end

  # Sets the attribute reactor
  #
  # @param value the value to set the attribute reactor to.
  #
  # source://async//lib/async/wrapper.rb#40
  def reactor=(_arg0); end

  # Wait fo the io to become either readable or writable.
  #
  # source://async//lib/async/wrapper.rb#66
  def wait_any(timeout = T.unsafe(nil)); end

  # Wait for the io to become writable.
  #
  # source://async//lib/async/wrapper.rb#55
  def wait_priority(timeout = T.unsafe(nil)); end

  # Wait for the io to become readable.
  #
  # source://async//lib/async/wrapper.rb#50
  def wait_readable(timeout = T.unsafe(nil)); end

  # Wait for the io to become writable.
  #
  # source://async//lib/async/wrapper.rb#60
  def wait_writable(timeout = T.unsafe(nil)); end
end

# An exception that occurs when the asynchronous operation was cancelled.
#
# source://async//lib/async/wrapper.rb#28
class Async::Wrapper::Cancelled < ::StandardError; end

# Extensions to all Ruby objects.
#
# source://async//lib/kernel/async.rb#25
module Kernel
  # Run the given block of code in a task, asynchronously, creating a reactor if necessary.
  #
  # The preferred method to invoke asynchronous behavior at the top level.
  #
  # - When invoked within an existing reactor task, it will run the given block
  # asynchronously. Will return the task once it has been scheduled.
  # - When invoked at the top level, will create and run a reactor, and invoke
  # the block as an asynchronous task. Will block until the reactor finishes
  # running.
  #
  # source://async//lib/kernel/async.rb#41
  def Async(*_arg0, **_arg1, &_arg2); end

  # Run the given block of code synchronously, but within a reactor if not already in one.
  #
  # source://async//lib/kernel/sync.rb#34
  def Sync(&block); end
end
