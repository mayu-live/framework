ITEMS = [
  "Component-based, inspired by React",
  "JSX-inspired syntax",
  "100% server side",
  "100% async",
  "CSS-modules",
  "Asset handling (image compression etc)",
  "Hot-reloading",
]

def self.get_initial_state(**props)
  { index: 0 }
end

def mount
  loop do
    sleep 1

    update do |state|
      { index: state[:index].succ % ITEMS.size }
    end
  end
end

def render
  <div>
    <article class={styles.features}>
      <h2>Features</h2>

      <p>Here's a list of core features:</p>

      <ul>
        {ITEMS.each_with_index.map do |item, index|
          active = index == state[:index]
          <li class={active && styles.active}>
            {item}
          </li>
        end}
      </ul>
    </article>

    <div class={styles[:sections]}>
      <section class={styles[:section]}>
        <h2 class={styles[:sectionTitle]}>Interactive web apps without JavaScript</h2>
        <p>
          You write all logic in Ruby. Everything runs on the server.
        </p>
      </section>

      <section class={styles[:section]}>
        <h2 class={styles[:sectionTitle]}>But how does it work?</h2>
        <p>
          Mayu implements a Virtual DOM in Ruby.
          All DOM updates are streamed to the browser via Server-Sent Events.
        </p>
        <ul>
          <li>
            All callbacks run on the server.
          </li>
          <li>
            Your callback handlers are your endpoints.
          </li>
          <li>
            There is no need to for an API.
          </li>
        </ul>
        <p>
          Mayu needs 10kB of JavaScript (before gzip) to be able to patch the DOM.
          This loads before the page has been rendered.
        </p>
      </section>

      <section class={styles[:section]}>
        <h2 class={styles[:sectionTitle]}>Efficient</h2>
        <p>HTTP/2 makes everything load in parallel.</p>
        <p>Designed to be deployed near users, either on fly.io or maybe even an on-premise Raspberry PI.</p>
        <p>Elements are interactive immediately as the page loads. No need to wait for a huge JS bundle to load for the page to become interactive.</p>
      </section>

      <section class={styles[:section]}>
        <h2 class={styles[:sectionTitle]}>Smooth developer experience</h2>
        <p>Hot-reloading reloads your components as you edit them and shows the updates in real-time.</p>
        <p>Ruby is pretty nice.</p>
        <p>Asynchronous code without callbacks.</p>
      </section>
    </div>
  </div>
end
